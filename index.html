<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Circuit Schematic Drawing Tool - v2.0 with Diode</title>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      margin: 0; 
      padding: 0; 
      overflow: hidden;
      width: 100vw;
      height: 100vh;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    /* Custom Dialog Styles */
    #customDialog {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    #dialogBox {
      background: white;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      min-width: 400px;
      animation: slideIn 0.3s ease;
    }
    @keyframes slideIn {
      from {
        transform: translateY(-50px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    #dialogBox h3 {
      margin: 0 0 20px 0;
      color: #333;
      font-size: 1.4rem;
    }
    #dialogBox label {
      display: block;
      margin-bottom: 8px;
      color: #555;
      font-weight: 600;
      font-size: 0.95rem;
    }
    #dialogBox input {
      width: 100%;
      padding: 12px;
      margin-bottom: 20px;
      border: 2px solid #ddd;
      border-radius: 6px;
      font-size: 1rem;
      box-sizing: border-box;
      transition: border-color 0.2s;
    }
    #dialogBox input:focus {
      outline: none;
      border-color: #ff6600;
    }
    #dialogButtons {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }
    #dialogButtons button {
      padding: 10px 24px;
      border: none;
      border-radius: 6px;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    #dialogButtons .btn-cancel {
      background: #e0e0e0;
      color: #333;
    }
    #dialogButtons .btn-cancel:hover {
      background: #d0d0d0;
    }
    #dialogButtons .btn-ok {
      background: #ff6600;
      color: white;
    }
    #dialogButtons .btn-ok:hover {
      background: #e65c00;
    }
  </style>
</head>
<body>
  <!-- Custom Dialog -->
  <div id="customDialog">
    <div id="dialogBox">
      <h3 id="dialogTitle">Edit Component</h3>
      <div id="dialogContent">
        <label for="labelInput">Label:</label>
        <input type="text" id="labelInput" placeholder="Enter label (e.g., R1, C2)">
        <label for="valueInput">Value <span id="unitLabel" style="color:#888; font-weight:normal;"></span>:</label>
        <input type="text" id="valueInput" placeholder="Enter value (e.g., 10, 5)">
        <div id="resistanceContainer" style="display:none;">
          <label for="resistanceInput">Internal Resistance (Œ©):</label>
          <input type="text" id="resistanceInput" placeholder="Enter resistance (e.g., 0.1)">
        </div>
      </div>
      <p id="dialogMessage" style="margin:0; color:#555; line-height:1.5;"></p>
      <div id="dialogButtons">
        <button class="btn-cancel" onclick="closeDialog(false)">Cancel</button>
        <button class="btn-ok" onclick="closeDialog(true)">OK</button>
      </div>
    </div>
  </div>
  
  <!-- Custom Cell Dialog -->
  <div id="customCellDialog" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 1000; justify-content: center; align-items: center; overflow-y: auto;">
    <div style="background: white; padding: 30px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3); width: 600px; max-width: 90%; max-height: 90vh; overflow-y: auto; margin: 20px; animation: slideIn 0.3s ease;">
      <h3 style="margin: 0 0 20px 0; color: #333; font-size: 1.4rem;">Custom Battery Cell</h3>
      
      <div style="margin-bottom: 20px; padding: 15px; background: #f0f8ff; border-left: 4px solid #5aaeFF; border-radius: 4px;">
        <p style="margin: 0; font-size: 0.9rem; color: #555;">
          Enter battery specifications below or upload a JSON file.
        </p>
      </div>
      
      <!-- Form Fields -->
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
        <!-- Basic Properties -->
        <div style="grid-column: 1 / -1;">
          <label style="display: block; margin-bottom: 5px; color: #333; font-weight: 600; font-size: 0.9rem;">Cell Name *</label>
          <input type="text" id="customCellName" placeholder="e.g., Custom LiFePO4" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-size: 0.9rem; box-sizing: border-box;">
        </div>
        
        <div>
          <label style="display: block; margin-bottom: 5px; color: #333; font-weight: 600; font-size: 0.9rem;">Voltage (V) *</label>
          <input type="number" id="customCellVoltage" step="0.1" placeholder="3.7" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-size: 0.9rem; box-sizing: border-box;">
        </div>
        
        <div>
          <label style="display: block; margin-bottom: 5px; color: #333; font-weight: 600; font-size: 0.9rem;">Capacity (mAh) *</label>
          <input type="number" id="customCellCapacity" step="1" placeholder="3000" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-size: 0.9rem; box-sizing: border-box;">
        </div>
        
        <div>
          <label style="display: block; margin-bottom: 5px; color: #333; font-weight: 600; font-size: 0.9rem;">Chemistry *</label>
          <select id="customCellChemistry" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-size: 0.9rem; box-sizing: border-box;">
            <option value="Li-ion">Li-ion</option>
            <option value="LiFePO4">LiFePO4</option>
            <option value="Li-Po">Li-Po</option>
            <option value="NiMH">NiMH</option>
            <option value="NiCd">NiCd</option>
            <option value="Alkaline">Alkaline</option>
            <option value="Lithium">Lithium</option>
            <option value="Custom">Custom</option>
          </select>
        </div>
        
        <div id="customChemistryContainer" style="display: none; grid-column: 1 / -1;">
          <label style="display: block; margin-bottom: 5px; color: #333; font-weight: 600; font-size: 0.9rem;">Custom Chemistry Description</label>
          <input type="text" id="customChemistryDescription" placeholder="e.g., Solid-state lithium metal" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-size: 0.9rem; box-sizing: border-box;">
        </div>
        
        <div>
          <label style="display: block; margin-bottom: 5px; color: #333; font-weight: 600; font-size: 0.9rem;">Weight (g)</label>
          <input type="number" id="customCellWeight" step="0.1" placeholder="48" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-size: 0.9rem; box-sizing: border-box;">
        </div>
        
        <div>
          <label style="display: block; margin-bottom: 5px; color: #333; font-weight: 600; font-size: 0.9rem;">Diameter (mm)</label>
          <input type="number" id="customCellDiameter" step="0.1" placeholder="18.5" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-size: 0.9rem; box-sizing: border-box;">
        </div>
        
        <div>
          <label style="display: block; margin-bottom: 5px; color: #333; font-weight: 600; font-size: 0.9rem;">Length (mm)</label>
          <input type="number" id="customCellLength" step="0.1" placeholder="65.2" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-size: 0.9rem; box-sizing: border-box;">
        </div>
        
        <!-- Temperature Properties -->
        <div style="grid-column: 1 / -1; margin-top: 10px; padding-top: 10px; border-top: 2px solid #eee;">
          <h4 style="margin: 0 0 10px 0; color: #333; font-size: 1rem;">Temperature Properties</h4>
        </div>
        
        <div>
          <label style="display: block; margin-bottom: 5px; color: #333; font-weight: 600; font-size: 0.9rem;">Min Temp (¬∞C)</label>
          <input type="number" id="customCellTempMin" step="1" placeholder="-20" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-size: 0.9rem; box-sizing: border-box;">
        </div>
        
        <div>
          <label style="display: block; margin-bottom: 5px; color: #333; font-weight: 600; font-size: 0.9rem;">Max Temp (¬∞C)</label>
          <input type="number" id="customCellTempMax" step="1" placeholder="60" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-size: 0.9rem; box-sizing: border-box;">
        </div>
        
        <div>
          <label style="display: block; margin-bottom: 5px; color: #333; font-weight: 600; font-size: 0.9rem;">Optimal Temp (¬∞C)</label>
          <input type="number" id="customCellTempOptimal" step="1" placeholder="20" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-size: 0.9rem; box-sizing: border-box;">
        </div>
        
        <div>
          <label style="display: block; margin-bottom: 5px; color: #333; font-weight: 600; font-size: 0.9rem;">Temp Coeff (%/¬∞C)</label>
          <input type="number" id="customCellTempCoeff" step="0.1" placeholder="-0.5" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-size: 0.9rem; box-sizing: border-box;">
        </div>
        
        <!-- Electrical Properties -->
        <div style="grid-column: 1 / -1; margin-top: 10px; padding-top: 10px; border-top: 2px solid #eee;">
          <h4 style="margin: 0 0 10px 0; color: #333; font-size: 1rem;">Electrical Properties</h4>
        </div>
        
        <div>
          <label style="display: block; margin-bottom: 5px; color: #333; font-weight: 600; font-size: 0.9rem;">Internal R (mŒ©)</label>
          <input type="number" id="customCellResistance" step="1" placeholder="45" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-size: 0.9rem; box-sizing: border-box;">
        </div>
        
        <div>
          <label style="display: block; margin-bottom: 5px; color: #333; font-weight: 600; font-size: 0.9rem;">Thermal Eff (%)</label>
          <input type="number" id="customCellEfficiency" step="0.1" min="0" max="100" placeholder="95" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-size: 0.9rem; box-sizing: border-box;">
        </div>
        
        <div>
          <label style="display: block; margin-bottom: 5px; color: #333; font-weight: 600; font-size: 0.9rem;">Cycle Life</label>
          <input type="number" id="customCellCycleLife" step="1" placeholder="500" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-size: 0.9rem; box-sizing: border-box;">
        </div>
        
        <div>
          <label style="display: block; margin-bottom: 5px; color: #333; font-weight: 600; font-size: 0.9rem;">Self-Discharge</label>
          <input type="text" id="customCellSelfDischarge" placeholder="2-3%/month" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-size: 0.9rem; box-sizing: border-box;">
        </div>
        
        <div style="grid-column: 1 / -1; margin-top: 10px; padding-top: 10px; border-top: 2px solid #eee;">
          <h4 style="margin: 0 0 10px 0; color: #333; font-size: 1rem;">Electrochemical Reactions</h4>
        </div>
        
        <div style="grid-column: 1 / -1;">
          <label style="display: block; margin-bottom: 5px; color: #333; font-weight: 600; font-size: 0.9rem;">
            <span style="color: #d63031;">Cathode (Reduction during Discharge)</span>
          </label>
          <input type="text" id="customCellCathodeReaction" placeholder="LiCoO‚ÇÇ + Li‚Å∫ + e‚Åª ‚Üí Li‚ÇÅ‚Çã‚ÇìCoO‚ÇÇ" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-size: 0.9rem; box-sizing: border-box; margin-bottom: 8px;">
        </div>
        
        <div style="grid-column: 1 / -1;">
          <label style="display: block; margin-bottom: 5px; color: #333; font-weight: 600; font-size: 0.9rem;">
            <span style="color: #0984e3;">Anode (Oxidation during Discharge)</span>
          </label>
          <input type="text" id="customCellAnodeReaction" placeholder="LiC‚ÇÜ ‚Üí C‚ÇÜ + Li‚Å∫ + e‚Åª" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-size: 0.9rem; box-sizing: border-box; margin-bottom: 8px;">
        </div>
        
        <div style="grid-column: 1 / -1;">
          <label style="display: block; margin-bottom: 5px; color: #333; font-weight: 600; font-size: 0.9rem;">
            Overall Reaction (Discharge ‚Üí, Charge ‚Üê)
          </label>
          <input type="text" id="customCellReaction" placeholder="LiCoO‚ÇÇ + C‚ÇÜ ‚áå Li‚ÇÅ‚Çã‚ÇìCoO‚ÇÇ + Li‚ÇìC‚ÇÜ" style="width: 100%; padding: 8px; border: 2px solid #ddd; border-radius: 4px; font-size: 0.9rem; box-sizing: border-box; margin-bottom: 8px;">
        </div>
        
        <div style="grid-column: 1 / -1;">
          <!-- Chemical notation helper buttons -->
          <div style="display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 5px;">
            <span style="font-size: 0.8rem; color: #666; margin-right: 8px; align-self: center;">Subscripts:</span>
            <button onclick="insertChemical('‚ÇÄ', event)" style="padding: 4px 8px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">‚ÇÄ</button>
            <button onclick="insertChemical('‚ÇÅ', event)" style="padding: 4px 8px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">‚ÇÅ</button>
            <button onclick="insertChemical('‚ÇÇ', event)" style="padding: 4px 8px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">‚ÇÇ</button>
            <button onclick="insertChemical('‚ÇÉ', event)" style="padding: 4px 8px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">‚ÇÉ</button>
            <button onclick="insertChemical('‚ÇÑ', event)" style="padding: 4px 8px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">‚ÇÑ</button>
            <button onclick="insertChemical('‚ÇÖ', event)" style="padding: 4px 8px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">‚ÇÖ</button>
            <button onclick="insertChemical('‚ÇÜ', event)" style="padding: 4px 8px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">‚ÇÜ</button>
            <button onclick="insertChemical('‚Çá', event)" style="padding: 4px 8px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">‚Çá</button>
            <button onclick="insertChemical('‚Çà', event)" style="padding: 4px 8px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">‚Çà</button>
            <button onclick="insertChemical('‚Çâ', event)" style="padding: 4px 8px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">‚Çâ</button>
            <button onclick="insertChemical('‚Çì', event)" style="padding: 4px 8px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">‚Çì</button>
          </div>
          
          <div style="display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 5px;">
            <span style="font-size: 0.8rem; color: #666; margin-right: 8px; align-self: center;">Superscripts:</span>
            <button onclick="insertChemical('‚Å∫', event)" style="padding: 4px 8px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">‚Å∫</button>
            <button onclick="insertChemical('‚Åª', event)" style="padding: 4px 8px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">‚Åª</button>
            <button onclick="insertChemical('e‚Åª', event)" style="padding: 4px 10px; background: #ffe8e8; border: 1px solid #ffcccc; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">e‚Åª</button>
          </div>
          
          <div style="display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 5px;">
            <span style="font-size: 0.8rem; color: #666; margin-right: 8px; align-self: center;">Arrows:</span>
            <button onclick="insertChemical(' ‚Üí ', event)" style="padding: 4px 10px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">‚Üí</button>
            <button onclick="insertChemical(' ‚Üê ', event)" style="padding: 4px 10px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">‚Üê</button>
            <button onclick="insertChemical(' ‚áå ', event)" style="padding: 4px 10px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">‚áå</button>
            <button onclick="insertChemical(' ‚áÑ ', event)" style="padding: 4px 10px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">‚áÑ</button>
            <button onclick="insertChemical(' + ', event)" style="padding: 4px 10px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">+</button>
          </div>
          
          <div style="display: flex; flex-wrap: wrap; gap: 4px;">
            <span style="font-size: 0.8rem; color: #666; margin-right: 8px; align-self: center;">Elements:</span>
            <button onclick="insertChemical('Li', event)" style="padding: 4px 8px; background: #e8f4f8; border: 1px solid #b3d9e6; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">Li</button>
            <button onclick="insertChemical('Co', event)" style="padding: 4px 8px; background: #e8f4f8; border: 1px solid #b3d9e6; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">Co</button>
            <button onclick="insertChemical('Ni', event)" style="padding: 4px 8px; background: #e8f4f8; border: 1px solid #b3d9e6; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">Ni</button>
            <button onclick="insertChemical('Mn', event)" style="padding: 4px 8px; background: #e8f4f8; border: 1px solid #b3d9e6; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">Mn</button>
            <button onclick="insertChemical('Fe', event)" style="padding: 4px 8px; background: #e8f4f8; border: 1px solid #b3d9e6; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">Fe</button>
            <button onclick="insertChemical('O', event)" style="padding: 4px 8px; background: #e8f4f8; border: 1px solid #b3d9e6; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">O</button>
            <button onclick="insertChemical('C', event)" style="padding: 4px 8px; background: #e8f4f8; border: 1px solid #b3d9e6; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">C</button>
            <button onclick="insertChemical('H', event)" style="padding: 4px 8px; background: #e8f4f8; border: 1px solid #b3d9e6; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">H</button>
            <button onclick="insertChemical('Zn', event)" style="padding: 4px 8px; background: #e8f4f8; border: 1px solid #b3d9e6; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">Zn</button>
            <button onclick="insertChemical('P', event)" style="padding: 4px 8px; background: #e8f4f8; border: 1px solid #b3d9e6; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">P</button>
            <button onclick="insertChemical('Cl', event)" style="padding: 4px 8px; background: #e8f4f8; border: 1px solid #b3d9e6; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">Cl</button>
            <button onclick="insertChemical('N')" style="padding: 4px 8px; background: #e8f4f8; border: 1px solid #b3d9e6; border-radius: 3px; font-size: 0.85rem; cursor: pointer;">N</button>
          </div>
        </div>
      </div>
      
      <div style="display: flex; gap: 12px; margin-bottom: 15px;">
        <button id="uploadJsonBtn" style="flex: 1; padding: 12px 20px; background: #5aaeFF; color: white; border: none; border-radius: 6px; font-size: 0.95rem; cursor: pointer; transition: all 0.2s;">
          üìÅ Load from JSON
        </button>
      </div>
      
      <div style="display: flex; gap: 12px; justify-content: flex-end; margin-top: 20px;">
        <button onclick="closeCustomCellDialog()" style="padding: 10px 24px; background: #e0e0e0; color: #333; border: none; border-radius: 6px; font-size: 1rem; cursor: pointer; transition: all 0.2s;">
          Cancel
        </button>
        <button onclick="saveCustomCell()" style="padding: 10px 24px; background: #6a0dad; color: white; border: none; border-radius: 6px; font-size: 1rem; cursor: pointer; transition: all 0.2s;">
          Save Custom Cell
        </button>
      </div>
    </div>
  </div>
  
  <input type="file" id="importFileInput" style="display:none" accept="application/json">
  <canvas id="schematicCanvas"></canvas>
  
  <script>
  // Polyfill for roundRect (for older browsers)
  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
      this.moveTo(x + radius, y);
      this.lineTo(x + width - radius, y);
      this.arcTo(x + width, y, x + width, y + radius, radius);
      this.lineTo(x + width, y + height - radius);
      this.arcTo(x + width, y + height, x + width - radius, y + height, radius);
      this.lineTo(x + radius, y + height);
      this.arcTo(x, y + height, x, y + height - radius, radius);
      this.lineTo(x, y + radius);
      this.arcTo(x, y, x + radius, y, radius);
    };
  }
  
  // Custom dialog logic
  let dialogResolve = null;
  let currentElement = null;
  let currentUnit = '';
  
  // Circuit cycling logic
  const circuitTypes = ['series', 'parallel', 'divider', 'thevenin', 'norton'];
  let circuitEdited = false; // Track if user has edited the circuit
  
  function cycleCircuit() {
    currentCircuitIndex = (currentCircuitIndex + 1) % circuitTypes.length;
    loadDefaultCircuit(circuitTypes[currentCircuitIndex]);
  }

  function loadDefaultCircuit(type) {
    if (elements.length > 0 && circuitEdited) {
      showConfirmDialog('This will clear the current circuit. Continue?').then(confirmed => {
        if (confirmed) {
          loadCircuit(type);
        }
      });
    } else {
      loadCircuit(type);
    }
  }

  function loadCircuit(type) {
    // Save state for undo
    undoStack.push([...elements]);
    redoStack = [];
    
    // Reset counters
    resistorCount = 0;
    capacitorCount = 0;
    inductorCount = 0;
    diodeCount = 0;
    batteryCount = 0;
    selectedNode = null;
    circuitEdited = false; // Reset edit flag when loading example circuit
    
    elements = [];
    
    // Update current circuit/pack name based on mode
    const circuitNamesMap = currentMode === 'Battery Pack' ? {
      'series': '3S1P Pack',
      'parallel': '1S3P Pack',
      'divider': '2S2P Pack',
      'thevenin': 'Custom Pack A',
      'norton': 'Custom Pack B'
    } : {
      'series': 'Series Circuit',
      'parallel': 'Parallel Circuit',
      'divider': 'Voltage Divider',
      'thevenin': 'Thevenin Equivalent',
      'norton': 'Norton Equivalent'
    };
    currentCircuitName = circuitNamesMap[type] || (currentMode === 'Battery Pack' ? 'Custom Pack' : 'Custom Circuit');
    currentCircuitIndex = circuitTypes.indexOf(type);
    
    // Determine resistance values based on mode
    const batteryResistance = currentMode === 'Battery Pack' ? '0.05 Œ©' : '0.1 Œ©';
    
    if (type === 'series') {
      // Simple series circuit: Battery - R1 - R2 (or 3S1P pack in battery mode)
      elements.push({ type: 'battery', x1: 150, y1: 200, x2: 150, y2: 300, label: 'B0', value: '5 V', resistance: batteryResistance });
      elements.push({ type: 'wire', x1: 150, y1: 300, x2: 250, y2: 300, label: '', value: '' });
      elements.push({ type: 'resistor', x1: 250, y1: 300, x2: 400, y2: 300, label: 'R0', value: '5 Œ©' });
      elements.push({ type: 'resistor', x1: 400, y1: 300, x2: 550, y2: 300, label: 'R1', value: '5 Œ©' });
      elements.push({ type: 'wire', x1: 550, y1: 300, x2: 650, y2: 300, label: '', value: '' });
      elements.push({ type: 'wire', x1: 650, y1: 300, x2: 650, y2: 200, label: '', value: '' });
      elements.push({ type: 'wire', x1: 650, y1: 200, x2: 150, y2: 200, label: '', value: '' });
      resistorCount = 2;
      batteryCount = 1;
    } else if (type === 'parallel') {
      // Parallel circuit: Battery with two parallel resistors (or 1S3P pack in battery mode)
      elements.push({ type: 'battery', x1: 150, y1: 200, x2: 150, y2: 300, label: 'B0', value: '5 V', resistance: batteryResistance });
      elements.push({ type: 'wire', x1: 150, y1: 300, x2: 300, y2: 300, label: '', value: '' });
      // Top branch
      elements.push({ type: 'resistor', x1: 300, y1: 250, x2: 500, y2: 250, label: 'R0', value: '5 Œ©' });
      // Bottom branch
      elements.push({ type: 'resistor', x1: 300, y1: 350, x2: 500, y2: 350, label: 'R1', value: '5 Œ©' });
      elements.push({ type: 'wire', x1: 300, y1: 300, x2: 300, y2: 250, label: '', value: '' });
      elements.push({ type: 'wire', x1: 300, y1: 300, x2: 300, y2: 350, label: '', value: '' });
      elements.push({ type: 'wire', x1: 500, y1: 250, x2: 500, y2: 300, label: '', value: '' });
      elements.push({ type: 'wire', x1: 500, y1: 350, x2: 500, y2: 300, label: '', value: '' });
      elements.push({ type: 'wire', x1: 500, y1: 300, x2: 600, y2: 300, label: '', value: '' });
      elements.push({ type: 'wire', x1: 600, y1: 300, x2: 600, y2: 200, label: '', value: '' });
      elements.push({ type: 'wire', x1: 600, y1: 200, x2: 150, y2: 200, label: '', value: '' });
      resistorCount = 2;
      batteryCount = 1;
    } else if (type === 'divider') {
      // Voltage divider circuit (or 2S2P pack in battery mode)
      elements.push({ type: 'battery', x1: 150, y1: 150, x2: 150, y2: 250, label: 'B0', value: '5 V', resistance: batteryResistance });
      elements.push({ type: 'wire', x1: 150, y1: 250, x2: 250, y2: 250, label: '', value: '' });
      elements.push({ type: 'resistor', x1: 250, y1: 250, x2: 250, y2: 350, label: 'R0', value: '5 Œ©' });
      elements.push({ type: 'resistor', x1: 250, y1: 350, x2: 250, y2: 450, label: 'R1', value: '5 Œ©' });
      elements.push({ type: 'wire', x1: 250, y1: 450, x2: 150, y2: 450, label: '', value: '' });
      elements.push({ type: 'wire', x1: 150, y1: 450, x2: 150, y2: 150, label: '', value: '' });
      resistorCount = 2;
      batteryCount = 1;
    } else if (type === 'thevenin') {
      // Thevenin equivalent circuit: Voltage source in series with resistance
      // Shows Vth (Thevenin voltage) and Rth (Thevenin resistance)
      elements.push({ type: 'battery', x1: 200, y1: 200, x2: 200, y2: 300, label: 'Vth', value: '10 V', resistance: batteryResistance });
      elements.push({ type: 'wire', x1: 200, y1: 300, x2: 300, y2: 300, label: '', value: '' });
      elements.push({ type: 'resistor', x1: 300, y1: 300, x2: 500, y2: 300, label: 'Rth', value: '2 Œ©' });
      // Load resistor
      elements.push({ type: 'resistor', x1: 500, y1: 300, x2: 500, y2: 450, label: 'RL', value: '8 Œ©' });
      elements.push({ type: 'wire', x1: 500, y1: 450, x2: 200, y2: 450, label: '', value: '' });
      elements.push({ type: 'wire', x1: 200, y1: 450, x2: 200, y2: 200, label: '', value: '' });
      resistorCount = 2;
      batteryCount = 1;
    } else if (type === 'norton') {
      // Norton equivalent circuit: Current source in parallel with resistance
      // Shows In (Norton current) and Rn (Norton resistance)
      // Representing current source as battery with special label
      elements.push({ type: 'battery', x1: 200, y1: 200, x2: 200, y2: 350, label: 'In', value: '5 A', resistance: batteryResistance });
      // Norton resistance in parallel
      elements.push({ type: 'resistor', x1: 350, y1: 200, x2: 350, y2: 350, label: 'Rn', value: '2 Œ©' });
      // Load resistor in parallel
      elements.push({ type: 'resistor', x1: 500, y1: 200, x2: 500, y2: 350, label: 'RL', value: '8 Œ©' });
      // Top wire connecting all parallel elements
      elements.push({ type: 'wire', x1: 200, y1: 200, x2: 350, y2: 200, label: '', value: '' });
      elements.push({ type: 'wire', x1: 350, y1: 200, x2: 500, y2: 200, label: '', value: '' });
      // Bottom wire connecting all parallel elements
      elements.push({ type: 'wire', x1: 200, y1: 350, x2: 350, y2: 350, label: '', value: '' });
      elements.push({ type: 'wire', x1: 350, y1: 350, x2: 500, y2: 350, label: '', value: '' });
      resistorCount = 2;
      batteryCount = 1;
    }
    
    redraw();
  }

  function showDialog(title, labelValue, valueValue, unit, element) {
    return new Promise((resolve) => {
      dialogResolve = resolve;
      currentUnit = unit || '';
      currentElement = element || null; // Store element reference for battery resistance
      document.getElementById('dialogTitle').textContent = title;
      
      // Show input fields, hide message
      document.getElementById('dialogContent').style.display = 'block';
      document.getElementById('dialogMessage').style.display = 'none';
      
      document.getElementById('labelInput').value = labelValue || '';
      
      // Strip unit from value if present
      let cleanValue = valueValue || '';
      if (currentUnit && cleanValue.endsWith(currentUnit)) {
        cleanValue = cleanValue.slice(0, -currentUnit.length).trim();
      }
      document.getElementById('valueInput').value = cleanValue;
      
      // Show unit in label
      const unitLabel = document.getElementById('unitLabel');
      if (currentUnit) {
        unitLabel.textContent = '(unit: ' + currentUnit + ')';
      } else {
        unitLabel.textContent = '';
      }
      
      // Show resistance field for batteries
      const resistanceContainer = document.getElementById('resistanceContainer');
      if (element && element.type === 'battery') {
        resistanceContainer.style.display = 'block';
        let cleanResistance = element.resistance || '0.1 Œ©';
        if (cleanResistance.endsWith(' Œ©')) {
          cleanResistance = cleanResistance.slice(0, -2).trim();
        }
        document.getElementById('resistanceInput').value = cleanResistance;
      } else {
        resistanceContainer.style.display = 'none';
      }
      
      document.getElementById('customDialog').style.display = 'flex';
      // Focus on first input
      setTimeout(() => document.getElementById('labelInput').focus(), 100);
    });
  }

  function showConfirmDialog(message) {
    return new Promise((resolve) => {
      dialogResolve = resolve;
      currentUnit = '';
      document.getElementById('dialogTitle').textContent = 'Confirm Action';
      
      // Hide input fields, show message
      document.getElementById('dialogContent').style.display = 'none';
      document.getElementById('dialogMessage').style.display = 'block';
      document.getElementById('dialogMessage').textContent = message;
      
      document.getElementById('customDialog').style.display = 'flex';
    });
  }

  function closeDialog(confirmed) {
    const dialog = document.getElementById('customDialog');
    dialog.style.display = 'none';
    if (dialogResolve) {
      if (confirmed) {
        let value = document.getElementById('valueInput').value.trim();
        // Append unit if not already present and unit exists
        if (currentUnit && value && !value.endsWith(currentUnit)) {
          value = value + ' ' + currentUnit;
        }
        const result = {
          label: document.getElementById('labelInput').value,
          value: value
        };
        // Add resistance for batteries
        if (currentElement && currentElement.type === 'battery') {
          let resistance = document.getElementById('resistanceInput').value.trim();
          if (resistance && !resistance.endsWith('Œ©')) {
            resistance = resistance + ' Œ©';
          }
          result.resistance = resistance;
        }
        dialogResolve(result);
      } else {
        dialogResolve(null);
      }
      dialogResolve = null;
      currentElement = null; // Clear element reference
    }
  }
  
  // Custom Cell Dialog Functions
  function showCustomCellDialog() {
    // Get current custom cell or defaults
    const customCell = batteryTypes.find(t => t.isCustom) || {};
    
    // Populate form with current values or defaults
    document.getElementById('customCellName').value = customCell.name || 'Custom Cell';
    document.getElementById('customCellVoltage').value = customCell.voltage || 3.7;
    document.getElementById('customCellCapacity').value = customCell.capacity || 3000;
    document.getElementById('customCellChemistry').value = customCell.chemistry || 'Li-ion';
    document.getElementById('customCellWeight').value = customCell.weight || 48;
    document.getElementById('customCellDiameter').value = customCell.diameter || 18.5;
    document.getElementById('customCellLength').value = customCell.length || 65.2;
    document.getElementById('customCellTempMin').value = customCell.tempMin !== undefined ? customCell.tempMin : -20;
    document.getElementById('customCellTempMax').value = customCell.tempMax !== undefined ? customCell.tempMax : 60;
    document.getElementById('customCellTempOptimal').value = customCell.tempOptimal !== undefined ? customCell.tempOptimal : 20;
    document.getElementById('customCellTempCoeff').value = customCell.tempCoefficient !== undefined ? customCell.tempCoefficient : -0.5;
    document.getElementById('customCellResistance').value = customCell.internalResistance !== undefined ? customCell.internalResistance : 45;
    document.getElementById('customCellEfficiency').value = customCell.thermalEfficiency !== undefined ? customCell.thermalEfficiency : 95;
    document.getElementById('customCellCycleLife').value = customCell.cycleLife || 500;
    document.getElementById('customCellSelfDischarge').value = customCell.selfDischarge || '2-3%/month';
    document.getElementById('customCellCathodeReaction').value = customCell.cathodeReaction || 'LiCoO‚ÇÇ + Li‚Å∫ + e‚Åª ‚Üí Li‚ÇÅ‚Çã‚ÇìCoO‚ÇÇ';
    document.getElementById('customCellAnodeReaction').value = customCell.anodeReaction || 'LiC‚ÇÜ ‚Üí C‚ÇÜ + Li‚Å∫ + e‚Åª';
    document.getElementById('customCellReaction').value = customCell.reaction || 'LiCoO‚ÇÇ + C‚ÇÜ ‚áå Li‚ÇÅ‚Çã‚ÇìCoO‚ÇÇ + Li‚ÇìC‚ÇÜ';
    document.getElementById('customChemistryDescription').value = customCell.customChemistryDescription || '';
    
    // Show/hide custom chemistry field based on selection
    const customContainer = document.getElementById('customChemistryContainer');
    if (customCell.chemistry === 'Custom') {
      customContainer.style.display = 'block';
    } else {
      customContainer.style.display = 'none';
    }
    
    // Set up focus tracking for reaction input fields
    const reactionFields = ['customCellCathodeReaction', 'customCellAnodeReaction', 'customCellReaction'];
    reactionFields.forEach(fieldId => {
      const field = document.getElementById(fieldId);
      field.addEventListener('focus', function() {
        lastFocusedReactionInput = this;
      });
    });
    
    const dialog = document.getElementById('customCellDialog');
    dialog.style.display = 'flex';
  }
  
  function closeCustomCellDialog() {
    const dialog = document.getElementById('customCellDialog');
    dialog.style.display = 'none';
    // Revert to previous battery type if user cancels
    if (batteryModules[selectedModuleIndex].cellType === 'Custom Cell') {
      // Find first non-custom battery
      const firstNonCustom = batteryTypes.find(t => !t.isCustom);
      if (firstNonCustom) {
        batteryModules[selectedModuleIndex].cellType = firstNonCustom.name;
      }
    }
    redraw();
  }
  
  // Track which input field was last focused for chemical insertion
  let lastFocusedReactionInput = null;
  
  function insertChemical(text, event) {
    event.preventDefault();
    
    // Determine which input to use
    let input = lastFocusedReactionInput;
    
    // If no field was focused, default to overall reaction field
    if (!input || !document.contains(input)) {
      input = document.getElementById('customCellReaction');
    }
    
    const start = input.selectionStart;
    const end = input.selectionEnd;
    const currentValue = input.value;
    
    // Insert text at cursor position
    input.value = currentValue.substring(0, start) + text + currentValue.substring(end);
    
    // Move cursor to end of inserted text
    const newCursorPos = start + text.length;
    input.selectionStart = newCursorPos;
    input.selectionEnd = newCursorPos;
    
    // Focus back on input
    input.focus();
  }
  
  function saveCustomCell() {
    // Validate required fields
    const name = document.getElementById('customCellName').value.trim();
    const voltage = parseFloat(document.getElementById('customCellVoltage').value);
    const capacity = parseFloat(document.getElementById('customCellCapacity').value);
    
    if (!name || !voltage || !capacity) {
      alert('Please fill in all required fields: Name, Voltage, and Capacity');
      return;
    }
    
    // Find Custom Cell entry and update it
    const customCellIndex = batteryTypes.findIndex(t => t.isCustom);
    if (customCellIndex !== -1) {
      const diameter = document.getElementById('customCellDiameter').value;
      const length = document.getElementById('customCellLength').value;
      const chemistry = document.getElementById('customCellChemistry').value || 'Li-ion';
      const customChemDesc = document.getElementById('customChemistryDescription').value;
      
      batteryTypes[customCellIndex] = {
        name: name,
        voltage: voltage,
        capacity: capacity,
        chemistry: chemistry,
        customChemistryDescription: customChemDesc || undefined,
        weight: parseFloat(document.getElementById('customCellWeight').value) || 48,
        diameter: diameter ? parseFloat(diameter) : null,
        length: length ? parseFloat(length) : null,
        cathodeReaction: document.getElementById('customCellCathodeReaction').value || 'LiCoO‚ÇÇ + Li‚Å∫ + e‚Åª ‚Üí Li‚ÇÅ‚Çã‚ÇìCoO‚ÇÇ',
        anodeReaction: document.getElementById('customCellAnodeReaction').value || 'LiC‚ÇÜ ‚Üí C‚ÇÜ + Li‚Å∫ + e‚Åª',
        reaction: document.getElementById('customCellReaction').value || 'LiCoO‚ÇÇ + C‚ÇÜ ‚áå Li‚ÇÅ‚Çã‚ÇìCoO‚ÇÇ + Li‚ÇìC‚ÇÜ',
        tempMin: parseFloat(document.getElementById('customCellTempMin').value) || -20,
        tempMax: parseFloat(document.getElementById('customCellTempMax').value) || 60,
        tempOptimal: parseFloat(document.getElementById('customCellTempOptimal').value) || 20,
        cycleLife: parseInt(document.getElementById('customCellCycleLife').value) || 500,
        selfDischarge: document.getElementById('customCellSelfDischarge').value || '2-3%/month',
        internalResistance: parseFloat(document.getElementById('customCellResistance').value) || 45,
        thermalEfficiency: parseFloat(document.getElementById('customCellEfficiency').value) || 95,
        tempCoefficient: parseFloat(document.getElementById('customCellTempCoeff').value) || -0.5,
        isCustom: true
      };
      
      // Update the selected battery type for the current module
      batteryModules[selectedModuleIndex].cellType = batteryTypes[customCellIndex].name;
      
      // Close dialog
      document.getElementById('customCellDialog').style.display = 'none';
      
      alert(`Custom cell "${name}" saved successfully!`);
      redraw();
    }
  }
  
  // Setup upload button in custom cell dialog
  document.addEventListener('DOMContentLoaded', function() {
    const uploadBtn = document.getElementById('uploadJsonBtn');
    if (uploadBtn) {
      uploadBtn.addEventListener('click', function() {
        document.getElementById('jsonFileInput').click();
      });
    }
    
    // Handle chemistry dropdown change to show/hide custom chemistry field
    const chemistrySelect = document.getElementById('customCellChemistry');
    if (chemistrySelect) {
      chemistrySelect.addEventListener('change', function() {
        const customContainer = document.getElementById('customChemistryContainer');
        if (this.value === 'Custom') {
          customContainer.style.display = 'block';
        } else {
          customContainer.style.display = 'none';
        }
      });
    }
  });

  // Handle Enter key in dialog
  document.addEventListener('keydown', function(e) {
    const dialog = document.getElementById('customDialog');
    if (dialog.style.display === 'flex') {
      if (e.key === 'Enter') {
        e.preventDefault();
        closeDialog(true);
      } else if (e.key === 'Escape') {
        e.preventDefault();
        closeDialog(false);
      }
    }
  });

  // Add selectNode tool logic (no-op for now)
  // You can implement node selection logic as needed
    function toggleVoltageFlow() {
      showVoltageFlowAnimation = !showVoltageFlowAnimation;
      
      if (showVoltageFlowAnimation) {
        // Start animation
        flowAnimationId = setInterval(() => {
          flowAnimationOffset = (flowAnimationOffset + 2) % 20;
          redraw();
        }, 50);
      } else {
        // Stop animation
        if (flowAnimationId) {
          clearInterval(flowAnimationId);
          flowAnimationId = null;
        }
        flowAnimationOffset = 0;
        redraw();
      }
    }
    
    function toggleInduction() {
      showInductionAnimation = !showInductionAnimation;
      redraw();
    }
    
    function nodeAnalysis() {
      // Example: fill sidebar with dummy values if a node is selected
      if (selectedNode) {
        // Calculate dummy V, I, R values based on circuit
        // In a real implementation, you would solve the circuit equations
        const voltage = '5.0 V';
        const current = '0.5 A';
        const resistance = '10.0 Œ©';
        
        document.getElementById('voltageResult').textContent = voltage;
        document.getElementById('currentResult').textContent = current;
        document.getElementById('resistanceResult').textContent = resistance;
      } else {
        document.getElementById('voltageResult').textContent = '-';
        document.getElementById('currentResult').textContent = '-';
        document.getElementById('resistanceResult').textContent = '-';
        alert('Select a node first.');
      }
    }
    
    function theveninToNorton() {
      // Convert between Thevenin and Norton equivalent circuits
      // Find if we have a Thevenin circuit (series voltage source and resistance)
      // or Norton circuit (parallel current source and resistance)
      
      showConfirmDialog('This will convert between Thevenin and Norton equivalent circuits. Continue?').then(confirmed => {
        if (!confirmed) return;
        
        // Simple conversion logic
        // Find battery and resistors
        const batteries = elements.filter(el => el.type === 'battery');
        const resistors = elements.filter(el => el.type === 'resistor');
        
        if (batteries.length === 0 || resistors.length === 0) {
          alert('Circuit must contain at least one battery and one resistor for conversion.');
          return;
        }
        
        // Get first battery and first resistor for conversion
        const battery = batteries[0];
        const resistor = resistors[0];
        
        // Parse values
        const vValue = parseFloat(battery.value) || 0;
        const rValue = parseFloat(resistor.value) || 1;
        
        // Check if it's labeled as Thevenin (Vth) or Norton (In)
        if (battery.label.includes('Vth') || battery.label.includes('V')) {
          // Convert Thevenin to Norton: In = Vth / Rth
          const iNorton = (vValue / rValue).toFixed(2);
          battery.label = 'In';
          battery.value = iNorton + ' A';
          resistor.label = 'Rn';
          alert(`Converted to Norton: In = ${iNorton} A, Rn = ${rValue} Œ©`);
        } else if (battery.label.includes('In') || battery.label.includes('I')) {
          // Convert Norton to Thevenin: Vth = In * Rn
          const vThevenin = (vValue * rValue).toFixed(2);
          battery.label = 'Vth';
          battery.value = vThevenin + ' V';
          resistor.label = 'Rth';
          alert(`Converted to Thevenin: Vth = ${vThevenin} V, Rth = ${rValue} Œ©`);
        } else {
          // Default: treat as Thevenin and convert to Norton
          const iNorton = (vValue / rValue).toFixed(2);
          battery.label = 'In';
          battery.value = iNorton + ' A';
          resistor.label = 'Rn';
          alert(`Converted to Norton: In = ${iNorton} A, Rn = ${rValue} Œ©`);
        }
        
        undoStack.push([...elements]);
        redoStack = [];
        redraw();
      });
    }
    
    function exportCircuit() {
      const data = JSON.stringify(elements, null, 2);
      const blob = new Blob([data], {type: 'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'circuit.json';
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 0);
    }

    function importCircuit() {
      document.getElementById('importFileInput').click();
    }

    document.getElementById('importFileInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(evt) {
        try {
          const data = JSON.parse(evt.target.result);
          if (Array.isArray(data)) {
            undoStack.push([...elements]);
            redoStack = [];
            elements = data;
            redraw();
          } else {
            alert('Invalid circuit file.');
          }
        } catch (err) {
          alert('Error reading file: ' + err.message);
        }
      };
      reader.readAsText(file);
      // Reset input so same file can be imported again if needed
      e.target.value = '';
    });
    const canvas = document.getElementById('schematicCanvas');
    const ctx = canvas.getContext('2d');
    
    // Make canvas fullscreen
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      updateDrawingArea();
      if (uiButtons.leftToolbar.length > 0) {
        initializeUIButtons(); // Reinitialize button positions
      }
      redraw();
    }
    window.addEventListener('resize', resizeCanvas);
    // Don't call resizeCanvas here - wait for DOMContentLoaded
    
    // UI Layout Constants
    const UI = {
      // Left toolbar
      leftToolbar: { x: 10, y: 70, width: 180, padding: 10, buttonHeight: 28, gap: 4 },
      // Right sidebar
      rightSidebar: { width: 220, padding: 15, y: 70 },
      // Top bar
      topBar: { height: 60, padding: 10 },
      // Bottom circuits
      bottomCircuits: { height: 80, padding: 10 },
      // Drawing area (calculated dynamically)
      drawingArea: {}
    };
    
    // Update drawing area based on window size
    function updateDrawingArea() {
      UI.drawingArea = {
        x: UI.leftToolbar.x + UI.leftToolbar.width + 20,
        y: UI.topBar.height + 10,
        width: canvas.width - (UI.leftToolbar.x + UI.leftToolbar.width + 20) - (UI.rightSidebar.width + 30),
        height: canvas.height - UI.topBar.height - UI.bottomCircuits.height - 20
      };
      UI.rightSidebar.x = canvas.width - UI.rightSidebar.width - 10;
    }
    
    let tool = 'wire';
    let drawing = false;
    let startX, startY;
  let elements = [];
  let undoStack = [];
  let redoStack = [];
  // Node selection and highlight logic
  let selectedNode = null;
  // Component counters for auto-labeling
  let resistorCount = 0;
  let capacitorCount = 0;
  let inductorCount = 0;
  let diodeCount = 0;
  let batteryCount = 0;
  // Area selection
  let selectionBox = null;
  let selectedElements = [];
  let selectedComponent = null; // Track selected component in select mode
  // Move tool
  let movingComponent = null;
  let moveOffset = { x: 0, y: 0 };
  // Voltage flow animation
  let showVoltageFlowAnimation = false;
  let showInductionAnimation = false;
  let flowAnimationOffset = 0;
  let flowAnimationId = null;
  
  // UI Buttons - will be populated dynamically
  let uiButtons = {
    leftToolbar: [],
    rightSidebar: [],
    topBar: [],
    bottomCircuits: [],
    modeToggle: [],
    generateSchema: []
  };
  let hoveredButton = null;
  let currentCircuitIndex = 0;
  const circuitNames = ['series', 'parallel', 'divider', 'thevenin', 'norton'];
  let currentCircuitName = 'No Circuit';
  let currentMode = 'Circuit Designer'; // 'Circuit Designer' or 'Battery Pack'
  
  // Battery Pack mode variables
  let batteryModules = [
    {
      id: 1,
      name: 'Module 1',
      cellType: '18650',
      seriesCount: 1,
      parallelCount: 1,
      configText: '1S1P'
    }
  ];
  let nextModuleId = 2;
  let selectedModuleIndex = 0;
  let batteryTypes = [
    { 
      name: '18650', voltage: 3.7, capacity: 3000, chemistry: 'Li-ion', weight: 45, diameter: 18, length: 65,
      cathodeReaction: 'LiCoO‚ÇÇ + xLi‚Å∫ + xe‚Åª ‚Üí Li‚ÇÅ‚Çã‚ÇìCoO‚ÇÇ',
      anodeReaction: 'Li‚ÇìC‚ÇÜ ‚Üí C‚ÇÜ + xLi‚Å∫ + xe‚Åª',
      reaction: 'LiCoO‚ÇÇ + C‚ÇÜ ‚áå Li‚ÇÅ‚Çã‚ÇìCoO‚ÇÇ + Li‚ÇìC‚ÇÜ',
      tempMin: -20, tempMax: 60, tempOptimal: 20,
      cycleLife: 500, selfDischarge: '2-3%/month', internalResistance: 50,
      thermalEfficiency: 95, tempCoefficient: -0.5 // % efficiency, %/¬∞C from optimal
    },
    { 
      name: '21700', voltage: 3.7, capacity: 5000, chemistry: 'Li-ion', weight: 70, diameter: 21, length: 70,
      cathodeReaction: 'LiNiMnCoO‚ÇÇ + xLi‚Å∫ + xe‚Åª ‚Üí Li‚ÇÅ‚Çã‚ÇìNiMnCoO‚ÇÇ',
      anodeReaction: 'Li‚ÇìC‚ÇÜ ‚Üí C‚ÇÜ + xLi‚Å∫ + xe‚Åª',
      reaction: 'LiNiMnCoO‚ÇÇ + C‚ÇÜ ‚áå Li‚ÇÅ‚Çã‚ÇìNiMnCoO‚ÇÇ + Li‚ÇìC‚ÇÜ',
      tempMin: -20, tempMax: 60, tempOptimal: 20,
      cycleLife: 800, selfDischarge: '2-3%/month', internalResistance: 40,
      thermalEfficiency: 96, tempCoefficient: -0.4
    },
    { 
      name: '26650', voltage: 3.7, capacity: 5000, chemistry: 'Li-ion', weight: 90, diameter: 26, length: 65,
      cathodeReaction: 'LiFePO‚ÇÑ + Li‚Å∫ + e‚Åª ‚Üí FePO‚ÇÑ',
      anodeReaction: 'LiC‚ÇÜ ‚Üí C‚ÇÜ + Li‚Å∫ + e‚Åª',
      reaction: 'LiFePO‚ÇÑ + C‚ÇÜ ‚áå FePO‚ÇÑ + LiC‚ÇÜ',
      tempMin: -20, tempMax: 60, tempOptimal: 25,
      cycleLife: 2000, selfDischarge: '2-3%/month', internalResistance: 35,
      thermalEfficiency: 97, tempCoefficient: -0.3
    },
    { 
      name: 'AA', voltage: 1.5, capacity: 2500, chemistry: 'Alkaline', weight: 23, diameter: 14.5, length: 50.5,
      cathodeReaction: '2MnO‚ÇÇ + 2H‚ÇÇO + 2e‚Åª ‚Üí 2MnO(OH) + 2OH‚Åª',
      anodeReaction: 'Zn + 2OH‚Åª ‚Üí ZnO + H‚ÇÇO + 2e‚Åª',
      reaction: 'Zn + 2MnO‚ÇÇ + 2NH‚ÇÑCl ‚Üí ZnCl‚ÇÇ + Mn‚ÇÇO‚ÇÉ + 2NH‚ÇÉ + H‚ÇÇO',
      tempMin: -18, tempMax: 55, tempOptimal: 21,
      cycleLife: 1, selfDischarge: '2-3%/year', internalResistance: 150,
      thermalEfficiency: 85, tempCoefficient: -1.0
    },
    { 
      name: 'AAA', voltage: 1.5, capacity: 1000, chemistry: 'Alkaline', weight: 11.5, diameter: 10.5, length: 44.5,
      cathodeReaction: '2MnO‚ÇÇ + 2H‚ÇÇO + 2e‚Åª ‚Üí 2MnO(OH) + 2OH‚Åª',
      anodeReaction: 'Zn + 2OH‚Åª ‚Üí ZnO + H‚ÇÇO + 2e‚Åª',
      reaction: 'Zn + 2MnO‚ÇÇ + 2NH‚ÇÑCl ‚Üí ZnCl‚ÇÇ + Mn‚ÇÇO‚ÇÉ + 2NH‚ÇÉ + H‚ÇÇO',
      tempMin: -18, tempMax: 55, tempOptimal: 21,
      cycleLife: 1, selfDischarge: '2-3%/year', internalResistance: 200,
      thermalEfficiency: 85, tempCoefficient: -1.0
    },
    { 
      name: 'D', voltage: 1.5, capacity: 12000, chemistry: 'Alkaline', weight: 135, diameter: 34.2, length: 61.5,
      cathodeReaction: '2MnO‚ÇÇ + 2H‚ÇÇO + 2e‚Åª ‚Üí 2MnO(OH) + 2OH‚Åª',
      anodeReaction: 'Zn + 2OH‚Åª ‚Üí ZnO + H‚ÇÇO + 2e‚Åª',
      reaction: 'Zn + 2MnO‚ÇÇ + 2NH‚ÇÑCl ‚Üí ZnCl‚ÇÇ + Mn‚ÇÇO‚ÇÉ + 2NH‚ÇÉ + H‚ÇÇO',
      tempMin: -18, tempMax: 55, tempOptimal: 21,
      cycleLife: 1, selfDischarge: '2-3%/year', internalResistance: 100,
      thermalEfficiency: 85, tempCoefficient: -1.0
    },
    { 
      name: '9V', voltage: 9, capacity: 500, chemistry: 'Alkaline', weight: 45, diameter: 26.5, length: 48.5,
      cathodeReaction: '6 √ó (2MnO‚ÇÇ + 2H‚ÇÇO + 2e‚Åª ‚Üí 2MnO(OH) + 2OH‚Åª)',
      anodeReaction: '6 √ó (Zn + 2OH‚Åª ‚Üí ZnO + H‚ÇÇO + 2e‚Åª)',
      reaction: '6(Zn + 2MnO‚ÇÇ) in series',
      tempMin: -18, tempMax: 55, tempOptimal: 21,
      cycleLife: 1, selfDischarge: '2-3%/year', internalResistance: 1500,
      thermalEfficiency: 85, tempCoefficient: -1.0
    },
    { 
      name: 'CR2032', voltage: 3, capacity: 220, chemistry: 'Lithium', weight: 3, diameter: 20, length: 3.2,
      cathodeReaction: 'MnO‚ÇÇ + Li‚Å∫ + e‚Åª ‚Üí LiMnO‚ÇÇ',
      anodeReaction: 'Li ‚Üí Li‚Å∫ + e‚Åª',
      reaction: 'Li + MnO‚ÇÇ ‚Üí LiMnO‚ÇÇ',
      tempMin: -30, tempMax: 60, tempOptimal: 20,
      cycleLife: 1, selfDischarge: '<1%/year', internalResistance: 15000,
      thermalEfficiency: 90, tempCoefficient: -0.8
    },
    { 
      name: 'LiPo Cell', voltage: 3.7, capacity: 2000, chemistry: 'Li-Po', weight: 30, diameter: null, length: null,
      cathodeReaction: 'LiCoO‚ÇÇ + xLi‚Å∫ + xe‚Åª ‚Üí Li‚ÇÅ‚Çã‚ÇìCoO‚ÇÇ',
      anodeReaction: 'Li‚ÇìC‚ÇÜ ‚Üí C‚ÇÜ + xLi‚Å∫ + xe‚Åª',
      reaction: 'LiCoO‚ÇÇ + C‚ÇÜ ‚áå Li‚ÇÅ‚Çã‚ÇìCoO‚ÇÇ + Li‚ÇìC‚ÇÜ',
      tempMin: -20, tempMax: 60, tempOptimal: 25,
      cycleLife: 300, selfDischarge: '5%/month', internalResistance: 30,
      thermalEfficiency: 94, tempCoefficient: -0.6
    },
    { 
      name: 'Custom Cell', voltage: 3.7, capacity: 3000, chemistry: 'Li-ion', weight: 48, diameter: 18.5, length: 65.2,
      cathodeReaction: 'LiCoO‚ÇÇ + xLi‚Å∫ + xe‚Åª ‚Üí Li‚ÇÅ‚Çã‚ÇìCoO‚ÇÇ',
      anodeReaction: 'Li‚ÇìC‚ÇÜ ‚Üí C‚ÇÜ + xLi‚Å∫ + xe‚Åª',
      reaction: 'LiCoO‚ÇÇ + C‚ÇÜ ‚áå Li‚ÇÅ‚Çã‚ÇìCoO‚ÇÇ + Li‚ÇìC‚ÇÜ',
      tempMin: -20, tempMax: 60, tempOptimal: 20,
      cycleLife: 500, selfDischarge: '2-3%/month', internalResistance: 45,
      thermalEfficiency: 95, tempCoefficient: -0.5,
      isCustom: true 
    }
  ];
  let customBatteryCells = []; // Store uploaded custom cells
  let batteryDropdownOpen = false;
  let seriesDropdownOpen = false;
  let parallelDropdownOpen = false;
  let hoveredBatteryType = null;
  let hoveredSeriesCount = null;
  let hoveredParallelCount = null;
  let configInputFocused = false;
  let selectedBatteryInfo = null;
  let cursorVisible = true;
  
  // Cursor blink animation
  setInterval(() => {
    if (configInputFocused) {
      cursorVisible = !cursorVisible;
      redraw();
    }
  }, 500);
  
  // Toggle switch position
  const toggleSwitch = {
    x: 10,
    y: 25,
    width: 180,
    height: 32
  };
  
  function toggleMode() {
    currentMode = currentMode === 'Circuit Designer' ? 'Battery Pack' : 'Circuit Designer';
    // Update current name when switching modes
    if (currentCircuitName !== 'Multi-Module Pack: ' && !currentCircuitName.includes('Multi-Module Pack')) {
      if (currentMode === 'Battery Pack') {
        if (currentCircuitName === 'No Circuit') currentCircuitName = 'No Pack';
        else if (currentCircuitName.includes('Circuit')) {
          // Convert circuit names to pack names
          currentCircuitName = currentCircuitName
            .replace('Series Circuit', '3S1P Pack')
            .replace('Parallel Circuit', '1S3P Pack')
            .replace('Voltage Divider', '2S2P Pack')
            .replace('Thevenin Equivalent', 'Custom Pack A')
            .replace('Norton Equivalent', 'Custom Pack B')
            .replace('Custom Circuit', 'Custom Pack');
        }
      } else {
        if (currentCircuitName === 'No Pack') currentCircuitName = 'No Circuit';
        else if (currentCircuitName.includes('Pack')) {
          // Convert pack names back to circuit names
          currentCircuitName = currentCircuitName
            .replace('3S1P Pack', 'Series Circuit')
            .replace('1S3P Pack', 'Parallel Circuit')
            .replace('2S2P Pack', 'Voltage Divider')
            .replace('Custom Pack A', 'Thevenin Equivalent')
            .replace('Custom Pack B', 'Norton Equivalent')
            .replace('Custom Pack', 'Custom Circuit');
        }
      }
    }
    initializeUIButtons(); // Reinitialize buttons to update labels
    redraw();
  }
  
  // Parse configuration text like "3S2P" into series and parallel counts
  function parseConfigText() {
    const currentModule = batteryModules[selectedModuleIndex];
    const text = currentModule.configText.toUpperCase();
    const match = text.match(/(\d+)S(\d+)P/);
    if (match) {
      currentModule.seriesCount = parseInt(match[1]) || 1;
      currentModule.parallelCount = parseInt(match[2]) || 1;
    }
  }
  
  
  // Load example battery pack with specified configuration
  function loadExamplePack(series, parallel) {
    // Clear existing elements
    elements = [];
    
    const cellWidth = 40;
    const cellHeight = 80;
    const spacingX = 20;
    const spacingY = 20;
    const startX = 250;
    const startY = 200;
    
    // Use the first available battery type (usually Li-ion 18650)
    const cellInfo = batteryTypes[0];
    const cellVoltage = cellInfo.voltage || 3.7;
    const cellResistance = cellInfo.internalResistance || 0.05;
    
    const S = series;
    const P = parallel;
    
    let batteryIndex = 0;
    
    // Draw parallel groups connected in series
    for (let s = 0; s < S; s++) {
      // Draw P cells in parallel for this series position
      for (let p = 0; p < P; p++) {
        const x = startX + s * (cellWidth + spacingX);
        const y = startY + p * (cellHeight + spacingY);
        
        // Draw battery cell
        elements.push({
          type: 'battery',
          x1: x,
          y1: y,
          x2: x,
          y2: y + cellHeight,
          label: `B${batteryIndex++}`,
          value: `${cellVoltage}V`,
          resistance: `${cellResistance} Œ©`
        });
        
        // Connect parallel cells with vertical wires
        if (p > 0) {
          // Connect negative terminals (top)
          elements.push({
            type: 'wire',
            x1: x,
            y1: y,
            x2: x,
            y2: y - spacingY,
            label: '',
            value: ''
          });
          
          // Connect positive terminals (bottom)
          elements.push({
            type: 'wire',
            x1: x,
            y1: y + cellHeight,
            x2: x,
            y2: y + cellHeight + spacingY,
            label: '',
            value: ''
          });
        }
      }
      
      // Connect series groups (except last series group)
      if (s < S - 1) {
        const nextX = startX + (s + 1) * (cellWidth + spacingX);
        const currentX = startX + s * (cellWidth + spacingX);
        // Connect positive of this group to negative of next group
        elements.push({
          type: 'wire',
          x1: currentX,
          y1: startY + cellHeight,
          x2: nextX,
          y2: startY,
          label: '',
          value: ''
        });
      }
    }
    
    // Update circuit name
    const totalVoltage = (cellVoltage * S).toFixed(1);
    const packConfig = `${S}S${P}P`;
    currentCircuitName = `${packConfig} Pack (${totalVoltage}V)`;
    batteryCount = batteryIndex;
    
    circuitEdited = false;
    redraw();
  }
  
  // Generate battery pack schema
  function generateBatterySchema() {
    // Clear existing elements
    elements = [];
    
    const cellWidth = 40;
    const cellHeight = 80;
    const spacingX = 20;
    const spacingY = 20;
    const moduleSpacingY = 150; // Space between modules
    let startX = 200;
    let startY = 150;
    
    let totalBatteryCount = 0;
    
    // Generate schema for each module
    batteryModules.forEach((module, moduleIndex) => {
      const cellInfo = batteryTypes.find(t => t.name === module.cellType);
      if (!cellInfo) return;
      
      const S = module.seriesCount;
      const P = module.parallelCount;
      
      // Draw parallel groups connected in series
      for (let s = 0; s < S; s++) {
        // Draw P cells in parallel for this series position
        for (let p = 0; p < P; p++) {
          const x = startX + s * (cellWidth + spacingX);
          const y = startY + p * (cellHeight + spacingY);
          
          // Draw battery cell
          elements.push({
            type: 'battery',
            x1: x,
            y1: y,
            x2: x,
            y2: y + cellHeight,
            label: `M${module.id}-C${s * P + p + 1}`,
            value: `${cellInfo.voltage}V`,
            resistance: `${cellInfo.internalResistance || 0.05} Œ©`
          });
          
          // Connect parallel cells with horizontal wires (except last in parallel group)
          if (p > 0) {
            // Connect negative terminals
            elements.push({
              type: 'wire',
              x1: x,
              y1: y,
              x2: x,
              y2: y - spacingY,
              label: '',
              value: ''
            });
            
            // Connect positive terminals
            elements.push({
              type: 'wire',
              x1: x,
              y1: y + cellHeight,
              x2: x,
              y2: y + cellHeight + spacingY,
              label: '',
              value: ''
            });
          }
        }
        
        // Connect series groups (except last series group)
        if (s < S - 1) {
          const nextX = startX + (s + 1) * (cellWidth + spacingX);
          // Connect positive of this group to negative of next group
          elements.push({
            type: 'wire',
            x1: startX + s * (cellWidth + spacingX),
            y1: startY + cellHeight,
            x2: nextX,
            y2: startY,
            label: '',
            value: ''
          });
        }
      }
      
      totalBatteryCount += S * P;
      
      // Update startY for next module
      startY += Math.max(P * (cellHeight + spacingY), cellHeight) + moduleSpacingY;
    });
    
    batteryCount = totalBatteryCount;
    circuitEdited = true;
    
    // Create circuit name from all modules
    const moduleConfigs = batteryModules.map(m => `${m.configText} ${m.cellType}`).join(' + ');
    currentCircuitName = `Multi-Module Pack: ${moduleConfigs}`;
    redraw();
  }
  
  // Initialize UI buttons
  function initializeUIButtons() {
    updateDrawingArea();
    
    // Left toolbar buttons (drawing tools)
    const toolButtons = [
      { label: 'üëÜ Select Item', action: () => setTool('select'), tool: 'select' },
      { label: '‚óâ Select Node', action: () => setTool('selectNode'), tool: 'selectNode' },
      { label: '‚¨ö Select Area', action: () => setTool('selectArea'), tool: 'selectArea' },
      { label: '‚ú• Move', action: () => setTool('move'), tool: 'move' },
      { label: 'üóë Erase', action: () => setTool('erase'), tool: 'erase', isRed: true },
      { label: '---', action: null, tool: null }, // Separator
      { label: '‚îÅ Wire', action: () => setTool('wire'), tool: 'wire' },
      { label: '‚äè‚äê Resistor', action: () => setTool('resistor'), tool: 'resistor' },
      { label: '‚ä¢‚ä£ Capacitor', action: () => setTool('capacitor'), tool: 'capacitor' },
      { label: '‚äÇ‚äÉ Inductor', action: () => setTool('inductor'), tool: 'inductor' },
      { label: '‚ñ∑| Diode', action: () => setTool('diode'), tool: 'diode' },
      { label: '‚äï‚äñ Battery', action: () => setTool('battery'), tool: 'battery' },
      { label: '---', action: null, tool: null }, // Separator
      { label: '‚úã Pan', action: () => setTool('pan'), tool: 'pan' },
      { label: 'üîç+ Zoom In', action: zoomIn, tool: null },
      { label: 'üîç‚àí Zoom Out', action: zoomOut, tool: null },
      { label: '‚Üª Reset Zoom', action: resetZoom, tool: null }
    ];
    
    uiButtons.leftToolbar = toolButtons.map((btn, i) => ({
      x: UI.leftToolbar.x,
      y: UI.leftToolbar.y + i * (UI.leftToolbar.buttonHeight + UI.leftToolbar.gap),
      width: UI.leftToolbar.width,
      height: btn.label === '---' ? 2 : UI.leftToolbar.buttonHeight,
      label: btn.label,
      action: btn.action,
      tool: btn.tool,
      isSeparator: btn.label === '---',
      isRed: btn.isRed || false
    }));
    
    console.log('Left toolbar buttons created:', uiButtons.leftToolbar.length);
    console.log('Button labels:', uiButtons.leftToolbar.map(b => b.label).join(', '));
    
    // Right sidebar buttons
    const rightButtons = [
      { label: 'Show Voltage Flow', action: toggleVoltageFlow },
      { label: 'Show Induction', action: toggleInduction },
      { label: 'Node Analysis', action: nodeAnalysis },
      { label: 'Thevenin ‚Üî Norton', action: theveninToNorton }
    ];
    
    let rightY = UI.rightSidebar.y + 180; // Space for VIR display
    uiButtons.rightSidebar = rightButtons.map((btn, i) => ({
      x: UI.rightSidebar.x,
      y: rightY + i * (UI.leftToolbar.buttonHeight + UI.leftToolbar.gap),
      width: UI.rightSidebar.width,
      height: UI.leftToolbar.buttonHeight,
      label: btn.label,
      action: btn.action
    }));
    
    // Top bar buttons (positioned on the right side)
    uiButtons.topBar = [
      { x: canvas.width - 210, y: 10, width: 90, height: 30, label: 'Export', action: exportCircuit },
      { x: canvas.width - 110, y: 10, width: 90, height: 30, label: 'Import', action: importCircuit }
    ];
    
    // Bottom circuits buttons (centered) - labels change based on mode
    const circuitButtons = currentMode === 'Battery Pack' ? [
      { label: 'Next Pack', action: cycleCircuit },
      { label: '3S1P', action: () => loadExamplePack(3, 1) },
      { label: '1S3P', action: () => loadExamplePack(1, 3) },
      { label: '2S2P', action: () => loadExamplePack(2, 2) },
      { label: 'Custom A', action: () => loadExamplePack(4, 1) },
      { label: 'Custom B', action: () => loadExamplePack(2, 3) },
      { label: 'Clear', action: clearCanvas, isRed: true }
    ] : [
      { label: 'Next Circuit', action: cycleCircuit },
      { label: 'Series', action: () => loadDefaultCircuit('series') },
      { label: 'Parallel', action: () => loadDefaultCircuit('parallel') },
      { label: 'Divider', action: () => loadDefaultCircuit('divider') },
      { label: 'Thevenin', action: () => loadDefaultCircuit('thevenin') },
      { label: 'Norton', action: () => loadDefaultCircuit('norton') },
      { label: 'Clear', action: clearCanvas, isRed: true }
    ];
    
    // Calculate total width of buttons to center them
    let totalWidth = 0;
    circuitButtons.forEach((btn, i) => {
      const firstBtnWidth = currentMode === 'Battery Pack' ? 95 : 110;
      const width = (i === 0) ? firstBtnWidth : (btn.label === 'Clear' ? 80 : 85);
      totalWidth += width + (i > 0 ? 8 : 0); // Add gap except for first button
    });
    
    let bottomY = canvas.height - UI.bottomCircuits.height + 50; // Move buttons down to make room for title and circuit name
    let bottomX = (canvas.width - totalWidth) / 2; // Center the buttons
    uiButtons.bottomCircuits = circuitButtons.map((btn, i) => {
      const firstBtnWidth = currentMode === 'Battery Pack' ? 95 : 110;
      const width = (i === 0) ? firstBtnWidth : (btn.label === 'Clear' ? 80 : 85);
      const result = {
        x: bottomX,
        y: bottomY,
        width: width,
        height: 32,
        label: btn.label,
        action: btn.action,
        isRed: btn.isRed || false
      };
      bottomX += width + 8;
      return result;
    });
  }
  
  // Canvas control buttons (pan/zoom) - kept separate for backward compatibility
  let canvasButtons = [];
  // Pan and zoom
  let panOffset = { x: 0, y: 0 };
  let scale = 1;
  let isPanning = false;
  let panStart = { x: 0, y: 0 };

    function setTool(t) {
      tool = t;
      selectedComponent = null; // Clear selection when switching tools
      movingComponent = null; // Clear moving component
      
      // Reset cursor when switching tools
      if (t === 'pan') {
        canvas.style.cursor = 'grab';
      } else if (t === 'move') {
        canvas.style.cursor = 'move';
      } else {
        canvas.style.cursor = 'default';
      }
      
      // Redraw to update button highlights
      redraw();
    }
    // Set initial selected button
    window.addEventListener('DOMContentLoaded', () => {
      resizeCanvas(); // Initialize canvas size first
      initializeUIButtons();
      setTool(tool);
      redraw(); // Draw initial grid
    });
    function clearCanvas() {
      if (elements.length > 0) {
        undoStack.push([...elements]);
        redoStack = [];
      }
      elements = [];
      selectedNode = null;
      selectedComponent = null; // Clear selected component
      circuitEdited = false; // Reset edit flag when clearing
      currentCircuitName = currentMode === 'Battery Pack' ? 'No Pack' : 'No Circuit';
      redraw();
    }

    function zoomIn() {
      scale *= 1.2;
      canvas.style.cursor = 'default';
      redraw();
    }

    function zoomOut() {
      scale /= 1.2;
      canvas.style.cursor = 'default';
      redraw();
    }

    function resetZoom() {
      scale = 1;
      panOffset = { x: 0, y: 0 };
      canvas.style.cursor = 'default';
      redraw();
    }

    function getTransformedPoint(x, y) {
      return {
        x: (x - panOffset.x) / scale,
        y: (y - panOffset.y) / scale
      };
    }

    function drawWire(x1, y1, x2, y2, label, value, isSelected) {
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.strokeStyle = isSelected ? 'purple' : '#222';
      ctx.lineWidth = isSelected ? 3 : 2;
      ctx.stroke();
      
      // Draw voltage flow animation if enabled
      if (showVoltageFlowAnimation) {
        drawFlowArrows(x1, y1, x2, y2);
      }
      
      if (label || value) drawLabelAndValue(x1, y1, x2, y2, label, value);
    }
    
    function drawFlowArrows(x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const len = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx);
      
      ctx.save();
      ctx.strokeStyle = '#ff6600';
      ctx.fillStyle = '#ff6600';
      ctx.lineWidth = 2;
      
      // Draw animated arrows along the wire
      const arrowSpacing = 20;
      const numArrows = Math.floor(len / arrowSpacing);
      
      for (let i = 0; i < numArrows; i++) {
        const offset = (flowAnimationOffset + i * arrowSpacing) % len;
        const arrowX = x1 + (dx / len) * offset;
        const arrowY = y1 + (dy / len) * offset;
        
        // Draw arrow
        ctx.save();
        ctx.translate(arrowX, arrowY);
        ctx.rotate(angle);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-6, -3);
        ctx.lineTo(-6, 3);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
      
      ctx.restore();
    }
    function drawResistor(x1, y1, x2, y2, label, value) {
      // Draw a zigzag resistor between (x1, y1) and (x2, y2)
      const dx = x2 - x1, dy = y2 - y1;
      const len = Math.sqrt(dx*dx + dy*dy);
      const angle = Math.atan2(dy, dx);
      ctx.save();
      ctx.translate(x1, y1);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(len*0.2, 0);
      let z = 6, amp = 10;
      for (let i = 1; i <= z; i++) {
        ctx.lineTo(len*0.2 + (len*0.6/z)*i, (i%2 ? -amp : amp));
      }
      ctx.lineTo(len*0.8, 0);
      ctx.lineTo(len, 0);
      ctx.strokeStyle = '#b77f00';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
      if (label || value) drawLabelAndValue(x1, y1, x2, y2, label, value);
    }
    function drawCapacitor(x1, y1, x2, y2, label, value) {
      // Draw two parallel lines for capacitor
      const dx = x2 - x1, dy = y2 - y1;
      const len = Math.sqrt(dx*dx + dy*dy);
      const angle = Math.atan2(dy, dx);
      ctx.save();
      ctx.translate(x1, y1);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(len*0.4, 0);
      ctx.moveTo(len*0.4, -15);
      ctx.lineTo(len*0.4, 15);
      ctx.moveTo(len*0.6, -15);
      ctx.lineTo(len*0.6, 15);
      ctx.moveTo(len*0.6, 0);
      ctx.lineTo(len, 0);
      ctx.strokeStyle = '#0077b7';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
      if (label || value) drawLabelAndValue(x1, y1, x2, y2, label, value);
    }
    function drawInductor(x1, y1, x2, y2, label, value) {
      // Draw a coil/spiral inductor between (x1, y1) and (x2, y2)
      const dx = x2 - x1, dy = y2 - y1;
      const len = Math.sqrt(dx*dx + dy*dy);
      const angle = Math.atan2(dy, dx);
      ctx.save();
      ctx.translate(x1, y1);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(len*0.2, 0);
      // Draw coils
      const coils = 4;
      const coilWidth = (len*0.6) / coils;
      const coilHeight = 12;
      for (let i = 0; i < coils; i++) {
        const startX = len*0.2 + i*coilWidth;
        ctx.arc(startX + coilWidth/2, 0, coilHeight/2, Math.PI, 0, false);
      }
      ctx.lineTo(len, 0);
      ctx.strokeStyle = '#00aa00';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
      if (label || value) drawLabelAndValue(x1, y1, x2, y2, label, value);
    }
    
    function drawDiode(x1, y1, x2, y2, label, value) {
      // Draw a diode symbol between (x1, y1) and (x2, y2)
      const dx = x2 - x1, dy = y2 - y1;
      const len = Math.sqrt(dx*dx + dy*dy);
      const angle = Math.atan2(dy, dx);
      ctx.save();
      ctx.translate(x1, y1);
      ctx.rotate(angle);
      
      // Wire leading to diode
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(len*0.3, 0);
      ctx.strokeStyle = '#ff6600';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Triangle (anode)
      ctx.beginPath();
      ctx.moveTo(len*0.3, 0);
      ctx.lineTo(len*0.5, -12);
      ctx.lineTo(len*0.5, 12);
      ctx.closePath();
      ctx.fillStyle = '#ff6600';
      ctx.fill();
      ctx.strokeStyle = '#ff6600';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Cathode bar
      ctx.beginPath();
      ctx.moveTo(len*0.5, -12);
      ctx.lineTo(len*0.5, 12);
      ctx.strokeStyle = '#ff6600';
      ctx.lineWidth = 3;
      ctx.stroke();
      
      // Wire from diode
      ctx.beginPath();
      ctx.moveTo(len*0.5, 0);
      ctx.lineTo(len, 0);
      ctx.strokeStyle = '#ff6600';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      ctx.restore();
      if (label || value) drawLabelAndValue(x1, y1, x2, y2, label, value);
    }
    
    function drawBattery(x1, y1, x2, y2, label, value, resistance) {
      // Draw a battery symbol between (x1, y1) and (x2, y2)
      const dx = x2 - x1, dy = y2 - y1;
      const len = Math.sqrt(dx*dx + dy*dy);
      const angle = Math.atan2(dy, dx);
      ctx.save();
      ctx.translate(x1, y1);
      ctx.rotate(angle);
      // Main line
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(len*0.3, 0);
      ctx.strokeStyle = '#b70000';
      ctx.lineWidth = 2;
      ctx.stroke();
      // Battery plates
      ctx.beginPath();
      ctx.moveTo(len*0.3, -16);
      ctx.lineTo(len*0.3, 16);
      ctx.moveTo(len*0.38, -10);
      ctx.lineTo(len*0.38, 10);
      ctx.strokeStyle = '#b70000';
      ctx.lineWidth = 3;
      ctx.stroke();
      // End line
      ctx.beginPath();
      ctx.moveTo(len*0.38, 0);
      ctx.lineTo(len, 0);
      ctx.strokeStyle = '#b70000';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
      // Draw label, value, and resistance
      if (label || value || resistance) {
        drawBatteryLabels(x1, y1, x2, y2, label, value, resistance);
      }
    }
    
    function drawBatteryLabels(x1, y1, x2, y2, label, value, resistance) {
      // Draw label, value, and resistance for battery
      const mx = (x1 + x2) / 2;
      const my = (y1 + y2) / 2;
      // Offset perpendicular to the element
      const dx = x2 - x1, dy = y2 - y1;
      const len = Math.sqrt(dx*dx + dy*dy);
      let ox = 0, oy = 0;
      if (len > 0) {
        ox = -dy / len * 25; // perpendicular offset
        oy = dx / len * 25;
      }
      ctx.save();
      ctx.font = '14px Arial';
      ctx.fillStyle = '#333';
      ctx.textAlign = 'center';
      // Label above
      if (label) ctx.fillText(label, mx + ox, my + oy - 8);
      // Value in middle
      if (value) ctx.fillText(value, mx + ox, my + oy + 8);
      // Resistance below (in smaller font)
      if (resistance) {
        ctx.font = '12px Arial';
        ctx.fillStyle = '#666';
        ctx.fillText('r: ' + resistance, mx + ox, my + oy + 22);
      }
      ctx.restore();
    }
    function drawLabelAndValue(x1, y1, x2, y2, label, value) {
      // Draw label and value offset from the center of the element
      const mx = (x1 + x2) / 2;
      const my = (y1 + y2) / 2;
      // Offset perpendicular to the element
      const dx = x2 - x1, dy = y2 - y1;
      const len = Math.sqrt(dx*dx + dy*dy);
      let ox = 0, oy = 0;
      if (len > 0) {
        ox = -dy / len * 25; // perpendicular offset
        oy = dx / len * 25;
      }
      ctx.save();
      ctx.font = '14px Arial';
      ctx.fillStyle = '#333';
      ctx.textAlign = 'center';
      // Label above/to one side
      if (label) ctx.fillText(label, mx + ox, my + oy - 3);
      // Value below/to other side
      if (value) ctx.fillText(value, mx - ox, my - oy + 3);
      ctx.restore();
    }
    function eraseAt(x, y) {
      // Remove the last element near (x, y)
      for (let i = elements.length - 1; i >= 0; i--) {
        const el = elements[i];
        const dist = Math.abs(el.x1 - x) + Math.abs(el.y1 - y) + Math.abs(el.x2 - x) + Math.abs(el.y2 - y);
        if (dist < 40) {
          undoStack.push([...elements]);
          redoStack = [];
          elements.splice(i, 1);
          circuitEdited = true; // Mark circuit as edited
          break;
        }
      }
      redraw();
    }
    function drawGrid() {
      const gridSize = 25;
      ctx.save();
      ctx.strokeStyle = '#eee';
      ctx.lineWidth = 1;
      
      // Calculate the visible area in drawing area coordinates
      const startX = Math.floor(-panOffset.x / scale / gridSize) * gridSize;
      const endX = Math.ceil((UI.drawingArea.width - panOffset.x) / scale / gridSize) * gridSize;
      const startY = Math.floor(-panOffset.y / scale / gridSize) * gridSize;
      const endY = Math.ceil((UI.drawingArea.height - panOffset.y) / scale / gridSize) * gridSize;
      
      // Draw vertical lines
      for (let x = startX; x <= endX; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, endY);
        ctx.stroke();
      }
      
      // Draw horizontal lines
      for (let y = startY; y <= endY; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, y);
        ctx.stroke();
      }
      
      ctx.restore();
    }
    function redraw() {
      // Don't draw if UI isn't initialized yet
      if (!UI.drawingArea.width) {
        return;
      }
      
      ctx.save();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw UI background
      drawUIBackground();
      
      // Apply pan and zoom transformations for drawing area only
      ctx.save();
      ctx.beginPath();
      ctx.rect(UI.drawingArea.x, UI.drawingArea.y, UI.drawingArea.width, UI.drawingArea.height);
      ctx.clip();
      
      ctx.translate(UI.drawingArea.x + panOffset.x, UI.drawingArea.y + panOffset.y);
      ctx.scale(scale, scale);
      
      // Adjust grid drawing to account for drawing area offset
      drawGrid();
      
      for (const el of elements) {
        const isSelected = (selectedComponent === el);
        if (el.type === 'wire') drawWire(el.x1, el.y1, el.x2, el.y2, el.label, el.value, isSelected);
        if (el.type === 'resistor') drawResistor(el.x1, el.y1, el.x2, el.y2, el.label, el.value);
        if (el.type === 'capacitor') drawCapacitor(el.x1, el.y1, el.x2, el.y2, el.label, el.value);
        if (el.type === 'inductor') drawInductor(el.x1, el.y1, el.x2, el.y2, el.label, el.value);
        if (el.type === 'diode') drawDiode(el.x1, el.y1, el.x2, el.y2, el.label, el.value);
        if (el.type === 'battery') drawBattery(el.x1, el.y1, el.x2, el.y2, el.label, el.value, el.resistance);
      }
      // Draw selected node highlight
      if (selectedNode && tool === 'selectNode') {
        ctx.beginPath();
        ctx.arc(selectedNode.x, selectedNode.y, 10, 0, 2 * Math.PI);
        ctx.strokeStyle = '#ff6600';
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.7;
        ctx.stroke();
        ctx.globalAlpha = 1.0;
      }
      // Draw selected elements highlight
      if (selectedElements.length > 0 && tool === 'selectArea') {
        ctx.strokeStyle = '#ff6600';
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.5;
        for (const el of selectedElements) {
          ctx.beginPath();
          ctx.moveTo(el.x1, el.y1);
          ctx.lineTo(el.x2, el.y2);
          ctx.stroke();
        }
        ctx.globalAlpha = 1.0;
      }
      // Draw selection box
      if (selectionBox && tool === 'selectArea') {
        ctx.strokeStyle = '#0066ff';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.strokeRect(
          selectionBox.x1, 
          selectionBox.y1, 
          selectionBox.x2 - selectionBox.x1, 
          selectionBox.y2 - selectionBox.y1
        );
        ctx.setLineDash([]);
      }
      
      ctx.restore(); // Restore from clipping and transform
      
      // Draw all UI elements (in screen space)
      drawAllUI();
      
      ctx.restore(); // Final restore
    }
    
    // Draw UI background areas
    function drawUIBackground() {
      ctx.fillStyle = '#f0f0f0';
      
      // Top bar
      ctx.fillRect(0, 0, canvas.width, UI.topBar.height);
      
      // Left toolbar
      ctx.fillRect(UI.leftToolbar.x, UI.leftToolbar.y, UI.leftToolbar.width, canvas.height - UI.leftToolbar.y - UI.bottomCircuits.height);
      
      // Right sidebar
      ctx.fillRect(UI.rightSidebar.x, UI.rightSidebar.y, UI.rightSidebar.width, canvas.height - UI.rightSidebar.y - UI.bottomCircuits.height);
      
      // Bottom circuits area
      ctx.fillRect(0, canvas.height - UI.bottomCircuits.height, canvas.width, UI.bottomCircuits.height);
      
      // Drawing area background
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(UI.drawingArea.x, UI.drawingArea.y, UI.drawingArea.width, UI.drawingArea.height);
      
      // Drawing area border
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 1;
      ctx.strokeRect(UI.drawingArea.x, UI.drawingArea.y, UI.drawingArea.width, UI.drawingArea.height);
    }
    
    // Draw all UI elements
    function drawAllUI() {
      ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transformation
      
      // Draw title
      ctx.fillStyle = '#333';
      ctx.font = 'bold 24px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(currentMode, canvas.width / 2, 30);
      
      // Draw toggle switch
      drawToggleSwitch();
      
      // Draw all buttons based on mode
      if (currentMode === 'Circuit Designer') {
        drawButtons(uiButtons.leftToolbar, 'toolbar');
      } else {
        drawBatteryPackUI();
      }
      
      drawButtons(uiButtons.rightSidebar, 'normal');
      drawButtons(uiButtons.topBar, 'normal');
      drawButtons(uiButtons.bottomCircuits, 'normal');
      
      // Draw VIR display
      drawVIRDisplay();
      
      // Draw current circuit name
      drawCurrentCircuitName();
    }
    
    // Draw a set of buttons
    function drawButtons(buttons, type) {
      for (const btn of buttons) {
        // Handle separator
        if (btn.isSeparator) {
          ctx.strokeStyle = '#ccc';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(btn.x + 10, btn.y);
          ctx.lineTo(btn.x + btn.width - 10, btn.y);
          ctx.stroke();
          continue;
        }
        
        const isHovered = (hoveredButton === btn);
        const isActive = (type === 'toolbar' && tool === btn.tool);
        const isToggle = (type === 'toggle');
        
        // Button background
        if (btn.isRed) {
          ctx.fillStyle = isHovered ? '#ff5252' : '#ff6b6b';
        } else if (isToggle) {
          ctx.fillStyle = isHovered ? '#d0d0ff' : '#e0e0ff';
        } else if (isActive) {
          ctx.fillStyle = 'purple';
        } else if (isHovered) {
          ctx.fillStyle = '#e0e0e0';
        } else {
          ctx.fillStyle = '#fafafa';
        }
        
        ctx.fillRect(btn.x, btn.y, btn.width, btn.height);
        
        // Button border
        ctx.strokeStyle = isToggle ? '#6a0dad' : (isActive ? '#6a0dad' : '#bbb');
        ctx.lineWidth = isToggle ? 2 : 1;
        ctx.strokeRect(btn.x, btn.y, btn.width, btn.height);
        
        // Button text
        ctx.fillStyle = (isActive || btn.isRed || isToggle) ? (btn.isRed ? '#fff' : '#000') : '#333';
        ctx.font = isToggle ? 'bold 14px Arial' : '14px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(btn.label, btn.x + btn.width / 2, btn.y + btn.height / 2);
      }
    }
    
    // Draw toggle switch
    function drawToggleSwitch() {
      const ts = toggleSwitch;
      const isOn = currentMode === 'Battery Pack';
      
      // Label above toggle
      ctx.fillStyle = '#333';
      ctx.font = 'bold 13px Arial';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText(isOn ? 'Battery Pack' : 'Circuit Designer', ts.x, ts.y - 20);
      
      // Background track
      ctx.fillStyle = isOn ? '#6a0dad' : '#ccc';
      ctx.beginPath();
      ctx.roundRect(ts.x, ts.y, ts.width, ts.height, ts.height / 2);
      ctx.fill();
      
      // Sliding knob
      const knobX = isOn ? ts.x + ts.width - ts.height : ts.x;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(knobX + ts.height / 2, ts.y + ts.height / 2, ts.height / 2 - 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#999';
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    
    // Draw Battery Pack UI
    function drawBatteryPackUI() {
      const x = UI.leftToolbar.x;
      const y = UI.leftToolbar.y;
      const w = UI.leftToolbar.width;
      
      const currentModule = batteryModules[selectedModuleIndex];
      
      // Module selector section
      ctx.fillStyle = '#333';
      ctx.font = 'bold 14px Arial';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText('Battery Modules:', x, y);
      
      // Module tabs/buttons
      let moduleY = y + 22;
      const moduleHeight = 32;
      const addButtonWidth = 40;
      
      // Draw module selection buttons
      for (let i = 0; i < batteryModules.length; i++) {
        const moduleX = x + (i % 3) * (w / 3);
        const moduleRowY = moduleY + Math.floor(i / 3) * (moduleHeight + 5);
        const moduleW = Math.min(w / 3 - 5, 55);
        
        // Module button
        ctx.fillStyle = i === selectedModuleIndex ? '#ff6600' : '#f5f5f5';
        ctx.fillRect(moduleX, moduleRowY, moduleW, moduleHeight);
        ctx.strokeStyle = i === selectedModuleIndex ? '#ff6600' : '#ccc';
        ctx.lineWidth = 2;
        ctx.strokeRect(moduleX, moduleRowY, moduleW, moduleHeight);
        
        // Module text
        ctx.fillStyle = i === selectedModuleIndex ? '#fff' : '#333';
        ctx.font = 'bold 11px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`M${batteryModules[i].id}`, moduleX + moduleW / 2, moduleRowY + moduleHeight / 2);
        
        // Delete button (x) for modules > 1
        if (batteryModules.length > 1) {
          const deleteX = moduleX + moduleW - 14;
          const deleteY = moduleRowY + 4;
          ctx.fillStyle = i === selectedModuleIndex ? 'rgba(255,255,255,0.3)' : 'rgba(0,0,0,0.1)';
          ctx.beginPath();
          ctx.arc(deleteX + 6, deleteY + 6, 8, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.strokeStyle = i === selectedModuleIndex ? '#fff' : '#666';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(deleteX + 3, deleteY + 3);
          ctx.lineTo(deleteX + 9, deleteY + 9);
          ctx.moveTo(deleteX + 9, deleteY + 3);
          ctx.lineTo(deleteX + 3, deleteY + 9);
          ctx.stroke();
        }
      }
      
      // Add module button
      const addModuleRow = Math.floor(batteryModules.length / 3);
      const addModuleCol = batteryModules.length % 3;
      const addButtonX = x + addModuleCol * (w / 3);
      const addButtonY = moduleY + addModuleRow * (moduleHeight + 5);
      const addButtonW = Math.min(w / 3 - 5, 55);
      
      ctx.fillStyle = '#e8f4f8';
      ctx.fillRect(addButtonX, addButtonY, addButtonW, moduleHeight);
      ctx.strokeStyle = '#5aaeFF';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 3]);
      ctx.strokeRect(addButtonX, addButtonY, addButtonW, moduleHeight);
      ctx.setLineDash([]);
      
      ctx.fillStyle = '#5aaeFF';
      ctx.font = 'bold 20px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('+', addButtonX + addButtonW / 2, addButtonY + moduleHeight / 2);
      
      // Calculate next Y position for battery type section
      const nextSectionY = addButtonY + moduleHeight + 15;
      
      // Section title
      ctx.fillStyle = '#333';
      ctx.font = 'bold 14px Arial';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText('Battery Type:', x, nextSectionY);
      
      // Dropdown button
      const dropdownY = nextSectionY + 20;
      ctx.fillStyle = batteryDropdownOpen ? '#e0e0e0' : '#fafafa';
      ctx.fillRect(x, dropdownY, w, 30);
      ctx.strokeStyle = '#bbb';
      ctx.lineWidth = 1;
      ctx.strokeRect(x, dropdownY, w, 30);
      
      ctx.fillStyle = '#333';
      ctx.font = '14px Arial';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText(currentModule.cellType, x + 10, dropdownY + 15);
      
      // Dropdown arrow
      ctx.fillStyle = '#666';
      ctx.beginPath();
      ctx.moveTo(x + w - 20, dropdownY + 10);
      ctx.lineTo(x + w - 10, dropdownY + 20);
      ctx.lineTo(x + w - 30, dropdownY + 20);
      ctx.closePath();
      ctx.fill();
      
      // Configuration section
      const configY = dropdownY + 60;
      ctx.fillStyle = '#333';
      ctx.font = 'bold 14px Arial';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText('Configuration:', x, configY);
      
      // Series dropdown
      const seriesY = configY + 20;
      ctx.fillStyle = '#333';
      ctx.font = '12px Arial';
      ctx.fillText('Series:', x, seriesY);
      
      const seriesDropdownY = seriesY + 18;
      ctx.fillStyle = seriesDropdownOpen ? '#e0e0e0' : '#fafafa';
      ctx.fillRect(x, seriesDropdownY, w, 28);
      ctx.strokeStyle = '#bbb';
      ctx.lineWidth = 1;
      ctx.strokeRect(x, seriesDropdownY, w, 28);
      
      ctx.fillStyle = '#333';
      ctx.font = '14px Arial';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText(`${currentModule.seriesCount} cells`, x + 10, seriesDropdownY + 14);
      
      // Dropdown arrow for series
      ctx.fillStyle = '#666';
      ctx.beginPath();
      ctx.moveTo(x + w - 18, seriesDropdownY + 10);
      ctx.lineTo(x + w - 10, seriesDropdownY + 18);
      ctx.lineTo(x + w - 26, seriesDropdownY + 18);
      ctx.closePath();
      ctx.fill();
      
      // Parallel dropdown
      const parallelY = seriesDropdownY + 38;
      ctx.fillStyle = '#333';
      ctx.font = '12px Arial';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText('Parallel:', x, parallelY);
      
      const parallelDropdownY = parallelY + 18;
      ctx.fillStyle = parallelDropdownOpen ? '#e0e0e0' : '#fafafa';
      ctx.fillRect(x, parallelDropdownY, w, 28);
      ctx.strokeStyle = '#bbb';
      ctx.lineWidth = 1;
      ctx.strokeRect(x, parallelDropdownY, w, 28);
      
      ctx.fillStyle = '#333';
      ctx.font = '14px Arial';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText(`${currentModule.parallelCount} cells`, x + 10, parallelDropdownY + 14);
      
      // Dropdown arrow for parallel
      ctx.fillStyle = '#666';
      ctx.beginPath();
      ctx.moveTo(x + w - 18, parallelDropdownY + 10);
      ctx.lineTo(x + w - 10, parallelDropdownY + 18);
      ctx.lineTo(x + w - 26, parallelDropdownY + 18);
      ctx.closePath();
      ctx.fill();
      
      // Update config text
      currentModule.configText = `${currentModule.seriesCount}S${currentModule.parallelCount}P`;
      
      // Pack summary
      const summaryY = parallelDropdownY + 45;
      const cellInfo = batteryTypes.find(t => t.name === currentModule.cellType);
      if (cellInfo) {
        ctx.fillStyle = '#333';
        ctx.font = 'bold 13px Arial';
        ctx.fillText(`Module ${currentModule.id} Summary:`, x, summaryY);
        
        const totalVoltage = cellInfo.voltage * currentModule.seriesCount;
        const totalCapacity = cellInfo.capacity * currentModule.parallelCount;
        const totalCells = currentModule.seriesCount * currentModule.parallelCount;
        const totalWeight = cellInfo.weight * totalCells;
        
        let lineY = summaryY + 18;
        const lineHeight = 15;
        
        ctx.font = '12px Arial';
        ctx.fillStyle = '#444';
        ctx.fillText(`Config: ${currentModule.configText}`, x, lineY); lineY += lineHeight;
        ctx.fillText(`Voltage: ${totalVoltage.toFixed(1)}V`, x, lineY); lineY += lineHeight;
        ctx.fillText(`Capacity: ${totalCapacity}mAh`, x, lineY); lineY += lineHeight;
        ctx.fillText(`Cells: ${totalCells} total`, x, lineY); lineY += lineHeight;
        ctx.fillText(`Weight: ${totalWeight.toFixed(1)}g`, x, lineY); lineY += lineHeight;
        ctx.fillText(`Chemistry: ${cellInfo.chemistry}`, x, lineY); lineY += lineHeight;
        
        // Show custom chemistry description if available
        if (cellInfo.customChemistryDescription) {
          ctx.font = '10px Arial';
          ctx.fillStyle = '#666';
          ctx.fillText(`  (${cellInfo.customChemistryDescription})`, x, lineY); lineY += 12;
          ctx.font = '12px Arial';
          ctx.fillStyle = '#444';
        }
        
        // Additional technical details
        ctx.fillStyle = '#333';
        ctx.font = 'bold 12px Arial';
        lineY += 5;
        ctx.fillText('Technical Details:', x, lineY); lineY += lineHeight;
        
        ctx.font = '11px Arial';
        ctx.fillStyle = '#555';
        if (cellInfo.tempMin !== undefined && cellInfo.tempMax !== undefined) {
          ctx.fillText(`Temp Range: ${cellInfo.tempMin}¬∞C to ${cellInfo.tempMax}¬∞C`, x, lineY); lineY += lineHeight;
        }
        if (cellInfo.tempOptimal !== undefined) {
          ctx.fillText(`Optimal Temp: ${cellInfo.tempOptimal}¬∞C`, x, lineY); lineY += lineHeight;
        }
        if (cellInfo.cycleLife !== undefined) {
          ctx.fillText(`Cycle Life: ${cellInfo.cycleLife} cycles`, x, lineY); lineY += lineHeight;
        }
        if (cellInfo.selfDischarge !== undefined) {
          ctx.fillText(`Self-Discharge: ${cellInfo.selfDischarge}`, x, lineY); lineY += lineHeight;
        }
        if (cellInfo.internalResistance !== undefined) {
          ctx.fillText(`Internal R: ${cellInfo.internalResistance}mŒ©`, x, lineY); lineY += lineHeight;
        }
        
        // Electrochemical reactions
        if (cellInfo.cathodeReaction || cellInfo.anodeReaction || cellInfo.reaction) {
          ctx.fillStyle = '#333';
          ctx.font = 'bold 11px Arial';
          lineY += 5;
          ctx.fillText('Electrochemical Reactions:', x, lineY); lineY += lineHeight;
          
          ctx.font = '10px Arial';
          const maxWidth = w - 10;
          
          // Cathode reaction (reduction during discharge)
          if (cellInfo.cathodeReaction) {
            ctx.fillStyle = '#d63031';
            ctx.font = 'bold 10px Arial';
            ctx.fillText('Cathode (Reduction):', x, lineY); lineY += 12;
            
            ctx.font = '10px Arial';
            ctx.fillStyle = '#666';
            const words = cellInfo.cathodeReaction.split(' ');
            let line = '';
            for (let i = 0; i < words.length; i++) {
              const testLine = line + words[i] + ' ';
              const metrics = ctx.measureText(testLine);
              if (metrics.width > maxWidth && i > 0) {
                ctx.fillText(line, x, lineY);
                lineY += 12;
                line = words[i] + ' ';
              } else {
                line = testLine;
              }
            }
            ctx.fillText(line, x, lineY);
            lineY += 12;
          }
          
          // Anode reaction (oxidation during discharge)
          if (cellInfo.anodeReaction) {
            ctx.fillStyle = '#0984e3';
            ctx.font = 'bold 10px Arial';
            ctx.fillText('Anode (Oxidation):', x, lineY); lineY += 12;
            
            ctx.font = '10px Arial';
            ctx.fillStyle = '#666';
            const words = cellInfo.anodeReaction.split(' ');
            let line = '';
            for (let i = 0; i < words.length; i++) {
              const testLine = line + words[i] + ' ';
              const metrics = ctx.measureText(testLine);
              if (metrics.width > maxWidth && i > 0) {
                ctx.fillText(line, x, lineY);
                lineY += 12;
                line = words[i] + ' ';
              } else {
                line = testLine;
              }
            }
            ctx.fillText(line, x, lineY);
            lineY += 12;
          }
          
          // Overall reaction
          if (cellInfo.reaction) {
            ctx.fillStyle = '#333';
            ctx.font = 'bold 10px Arial';
            ctx.fillText('Overall (Discharge ‚Üí, Charge ‚Üê):', x, lineY); lineY += 12;
            
            ctx.font = '10px Arial';
            ctx.fillStyle = '#666';
            const words = cellInfo.reaction.split(' ');
            let line = '';
            for (let i = 0; i < words.length; i++) {
              const testLine = line + words[i] + ' ';
              const metrics = ctx.measureText(testLine);
              if (metrics.width > maxWidth && i > 0) {
                ctx.fillText(line, x, lineY);
                lineY += 12;
                line = words[i] + ' ';
              } else {
                line = testLine;
              }
            }
            ctx.fillText(line, x, lineY);
            lineY += lineHeight;
          }
        }
        
        // Thermal Energy Loss Calculations
        if (cellInfo.thermalEfficiency !== undefined || cellInfo.internalResistance !== undefined) {
          ctx.fillStyle = '#333';
          ctx.font = 'bold 11px Arial';
          lineY += 5;
          ctx.fillText('Thermal Energy Loss:', x, lineY); lineY += lineHeight;
          
          ctx.font = '10px Arial';
          ctx.fillStyle = '#666';
          
          // Calculate energy at optimal temperature
          const totalEnergyWh = (totalVoltage * totalCapacity) / 1000;
          
          // Loss due to internal resistance (at 1C discharge rate)
          if (cellInfo.internalResistance !== undefined) {
            const totalInternalR = (cellInfo.internalResistance * currentModule.seriesCount) / currentModule.parallelCount;
            const dischargeCurrent = totalCapacity / 1000; // 1C rate in Amps
            const powerLossW = Math.pow(dischargeCurrent, 2) * totalInternalR / 1000; // Convert mŒ© to Œ©
            const energyLossWh = powerLossW * 1; // 1 hour discharge
            const resistanceLossPercent = (energyLossWh / totalEnergyWh) * 100;
            
            ctx.fillText(`I¬≤R Loss (1C): ${energyLossWh.toFixed(2)}Wh (${resistanceLossPercent.toFixed(1)}%)`, x, lineY);
            lineY += 12;
          }
          
          // Thermal efficiency loss
          if (cellInfo.thermalEfficiency !== undefined) {
            const efficiencyLossPercent = 100 - cellInfo.thermalEfficiency;
            const efficiencyLossWh = totalEnergyWh * (efficiencyLossPercent / 100);
            
            ctx.fillText(`Heat Loss: ${efficiencyLossWh.toFixed(2)}Wh (${efficiencyLossPercent.toFixed(1)}%)`, x, lineY);
            lineY += 12;
          }
          
          // Temperature-dependent capacity loss
          if (cellInfo.tempCoefficient !== undefined && cellInfo.tempOptimal !== undefined) {
            ctx.fillText(`Temp Coeff: ${cellInfo.tempCoefficient}%/¬∞C from ${cellInfo.tempOptimal}¬∞C`, x, lineY);
            lineY += 12;
            
            // Example at different temperatures
            const coldTemp = 0;
            const hotTemp = 40;
            const coldTempDiff = coldTemp - cellInfo.tempOptimal;
            const hotTempDiff = hotTemp - cellInfo.tempOptimal;
            const coldCapacityLoss = Math.abs(coldTempDiff * cellInfo.tempCoefficient);
            const hotCapacityLoss = Math.abs(hotTempDiff * cellInfo.tempCoefficient);
            
            ctx.fillText(`  @ ${coldTemp}¬∞C: -${coldCapacityLoss.toFixed(1)}% capacity`, x, lineY);
            lineY += 12;
            ctx.fillText(`  @ ${hotTemp}¬∞C: -${hotCapacityLoss.toFixed(1)}% capacity`, x, lineY);
            lineY += 12;
          }
          
          // Total thermal energy available (accounting for efficiency)
          if (cellInfo.thermalEfficiency !== undefined) {
            const usableEnergyWh = totalEnergyWh * (cellInfo.thermalEfficiency / 100);
            ctx.fillStyle = '#d00';
            ctx.font = 'bold 10px Arial';
            ctx.fillText(`Usable Energy:`, x, lineY);
            lineY += 12;
            ctx.fillText(`${usableEnergyWh.toFixed(2)}Wh @ optimal temp`, x, lineY);
            lineY += lineHeight;
          }
        }
        
        // Generate Schema Button
        const buttonY = lineY + 10;
        const buttonHeight = 35;
        const isHovered = hoveredButton && hoveredButton.label === 'Generate Schema';
        
        ctx.fillStyle = isHovered ? '#5a00ad' : '#6a0dad';
        ctx.fillRect(x, buttonY, w, buttonHeight);
        ctx.strokeStyle = '#4a009d';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, buttonY, w, buttonHeight);
        
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Generate Schema', x + w / 2, buttonY + buttonHeight / 2);
        
        // Store button info for click detection
        if (!uiButtons.generateSchema) {
          uiButtons.generateSchema = [];
        }
        uiButtons.generateSchema[0] = {
          x: x,
          y: buttonY,
          width: w,
          height: buttonHeight,
          label: 'Generate Schema',
          action: generateBatterySchema
        };
        
        // Add editing tools section
        let toolY = buttonY + buttonHeight + 20;
        
        // Section header
        ctx.fillStyle = '#333';
        ctx.font = 'bold 13px Arial';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText('Editing Tools:', x, toolY);
        toolY += 20;
        
        // Define editing tool buttons
        const editingTools = [
          { label: 'üëÜ Select Item', tool: 'select' },
          { label: '‚¨ö Select Area', tool: 'selectArea' },
          { label: '‚ú• Move', tool: 'move' },
          { label: 'üóë Erase', tool: 'erase', isRed: true }
        ];
        
        // Draw editing tool buttons
        const toolButtonHeight = 32;
        const toolButtonGap = 4;
        
        if (!uiButtons.batteryEditTools) {
          uiButtons.batteryEditTools = [];
        }
        
        editingTools.forEach((toolBtn, i) => {
          const btnY = toolY + i * (toolButtonHeight + toolButtonGap);
          const isToolHovered = hoveredButton && hoveredButton.tool === toolBtn.tool;
          const isToolActive = tool === toolBtn.tool;
          
          // Button background
          if (toolBtn.isRed) {
            ctx.fillStyle = isToolHovered ? '#ff5252' : '#ff6b6b';
          } else if (isToolActive) {
            ctx.fillStyle = 'purple';
          } else if (isToolHovered) {
            ctx.fillStyle = '#e0e0e0';
          } else {
            ctx.fillStyle = '#fafafa';
          }
          
          ctx.fillRect(x, btnY, w, toolButtonHeight);
          
          // Button border
          ctx.strokeStyle = isToolActive ? '#6a0dad' : '#bbb';
          ctx.lineWidth = isToolActive ? 2 : 1;
          ctx.strokeRect(x, btnY, w, toolButtonHeight);
          
          // Button text
          ctx.fillStyle = (isToolActive || toolBtn.isRed) ? (toolBtn.isRed ? '#fff' : '#fff') : '#333';
          ctx.font = '13px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(toolBtn.label, x + w / 2, btnY + toolButtonHeight / 2);
          
          // Store button for click detection
          uiButtons.batteryEditTools[i] = {
            x: x,
            y: btnY,
            width: w,
            height: toolButtonHeight,
            label: toolBtn.label,
            tool: toolBtn.tool,
            action: () => setTool(toolBtn.tool)
          };
        });
      }
      
      // Draw dropdown options LAST so they appear on top of everything
      if (batteryDropdownOpen) {
        // Recalculate positions for dropdown
        const moduleY = y + 22;
        const moduleHeight = 32;
        const addModuleRow = Math.floor(batteryModules.length / 3);
        const addButtonY = moduleY + addModuleRow * (moduleHeight + 5);
        const nextSectionY = addButtonY + moduleHeight + 15;
        const dropdownY = nextSectionY + 20;
        
        const dropdownHeight = batteryTypes.length * 30;
        ctx.fillStyle = '#f8f8f8';
        ctx.fillRect(x, dropdownY + 30, w, dropdownHeight);
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, dropdownY + 30, w, dropdownHeight);
        
        batteryTypes.forEach((type, i) => {
          const optionY = dropdownY + 30 + i * 30;
          if (hoveredBatteryType === type.name) {
            ctx.fillStyle = '#e0e0ff';
            ctx.fillRect(x, optionY, w, 30);
          }
          
          ctx.fillStyle = '#333';
          ctx.font = '12px Arial';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          ctx.fillText(`${type.name}`, x + 10, optionY + 10);
          ctx.fillStyle = '#666';
          ctx.font = '10px Arial';
          ctx.fillText(`${type.voltage}V ${type.capacity}mAh ${type.chemistry}`, x + 10, optionY + 22);
        });
      }
      
      // Draw series dropdown options
      if (seriesDropdownOpen) {
        // Recalculate positions for series dropdown
        const moduleY = y + 22;
        const moduleHeight = 32;
        const addModuleRow = Math.floor(batteryModules.length / 3);
        const addButtonY = moduleY + addModuleRow * (moduleHeight + 5);
        const nextSectionY = addButtonY + moduleHeight + 15;
        const dropdownY = nextSectionY + 20;
        const configY = dropdownY + 60;
        const seriesY = configY + 20;
        const seriesDropdownY = seriesY + 18;
        
        const options = [1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16];
        const dropdownHeight = options.length * 28;
        
        ctx.fillStyle = '#f8f8f8';
        ctx.fillRect(x, seriesDropdownY + 28, w, dropdownHeight);
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, seriesDropdownY + 28, w, dropdownHeight);
        
        options.forEach((count, i) => {
          const optionY = seriesDropdownY + 28 + i * 28;
          if (hoveredSeriesCount === count) {
            ctx.fillStyle = '#e0e0ff';
            ctx.fillRect(x, optionY, w, 28);
          }
          
          ctx.fillStyle = '#333';
          ctx.font = '14px Arial';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          ctx.fillText(`${count} cells`, x + 10, optionY + 14);
        });
      }
      
      // Draw parallel dropdown options
      if (parallelDropdownOpen) {
        // Recalculate positions for parallel dropdown
        const moduleY = y + 22;
        const moduleHeight = 32;
        const addModuleRow = Math.floor(batteryModules.length / 3);
        const addButtonY = moduleY + addModuleRow * (moduleHeight + 5);
        const nextSectionY = addButtonY + moduleHeight + 15;
        const dropdownY = nextSectionY + 20;
        const configY = dropdownY + 60;
        const seriesY = configY + 20;
        const seriesDropdownY = seriesY + 18;
        const parallelY = seriesDropdownY + 38;
        const parallelDropdownY = parallelY + 18;
        
        const options = [1, 2, 3, 4, 5, 6, 7, 8, 10, 12];
        const dropdownHeight = options.length * 28;
        
        ctx.fillStyle = '#f8f8f8';
        ctx.fillRect(x, parallelDropdownY + 28, w, dropdownHeight);
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, parallelDropdownY + 28, w, dropdownHeight);
        
        options.forEach((count, i) => {
          const optionY = parallelDropdownY + 28 + i * 28;
          if (hoveredParallelCount === count) {
            ctx.fillStyle = '#e0e0ff';
            ctx.fillRect(x, optionY, w, 28);
          }
          
          ctx.fillStyle = '#333';
          ctx.font = '14px Arial';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          ctx.fillText(`${count} cells`, x + 10, optionY + 14);
        });
      }
    }
    
    // Draw VIR display panel
    function drawVIRDisplay() {
      const x = UI.rightSidebar.x;
      const y = UI.rightSidebar.y;
      const width = UI.rightSidebar.width;
      
      // Panel background
      ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
      ctx.fillRect(x, y, width, 160);
      
      // Border
      ctx.strokeStyle = '#6a0dad';
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, width, 160);
      
      // Title
      ctx.fillStyle = '#6a0dad';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Node Analysis', x + width / 2, y + 20);
      
      // Draw line under title
      ctx.strokeStyle = '#6a0dad';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x + 15, y + 30);
      ctx.lineTo(x + width - 15, y + 30);
      ctx.stroke();
      
      // VIR values
      ctx.fillStyle = '#333';
      ctx.font = '14px Arial';
      ctx.textAlign = 'left';
      
      const voltage = selectedNode ? '5.0 V' : '-';
      const current = selectedNode ? '0.5 A' : '-';
      const resistance = selectedNode ? '10.0 Œ©' : '-';
      
      ctx.fillText('Voltage (V): ', x + 15, y + 55);
      ctx.fillStyle = '#000';
      ctx.font = 'bold 14px Arial';
      ctx.fillText(voltage, x + 120, y + 55);
      
      ctx.fillStyle = '#333';
      ctx.font = '14px Arial';
      ctx.fillText('Current (I): ', x + 15, y + 85);
      ctx.fillStyle = '#000';
      ctx.font = 'bold 14px Arial';
      ctx.fillText(current, x + 120, y + 85);
      
      ctx.fillStyle = '#333';
      ctx.font = '14px Arial';
      ctx.fillText('Resistance (R): ', x + 15, y + 115);
      ctx.fillStyle = '#000';
      ctx.font = 'bold 14px Arial';
      ctx.fillText(resistance, x + 120, y + 115);
    }
    
    // Draw current circuit name and example circuits title
    function drawCurrentCircuitName() {
      const bottomY = canvas.height - UI.bottomCircuits.height;
      
      // Draw "Example Circuits" or "Example Packs" title based on mode
      ctx.fillStyle = '#333';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center';
      const exampleTitle = currentMode === 'Battery Pack' ? 'Example Packs' : 'Example Circuits';
      ctx.fillText(exampleTitle, canvas.width / 2, bottomY + 12);
      
      // Draw current circuit/pack name below title
      ctx.fillStyle = '#ff6600';
      ctx.font = 'bold 13px Arial';
      ctx.textAlign = 'center';
      const currentLabel = currentMode === 'Battery Pack' ? 'Current Pack: ' : 'Current: ';
      ctx.fillText(currentLabel + currentCircuitName, canvas.width / 2, bottomY + 30);
    }
    
    function drawCanvasControls() {
      // No longer needed - integrated into drawAllUI
    }
    
    function isPointInButton(x, y, btn) {
      return x >= btn.x && x <= btn.x + btn.width && 
             y >= btn.y && y <= btn.y + btn.height;
    }
    
    // Helper: find nearest endpoint to (x, y) within snapDist, return {x, y} or null
    function findNearestEndpoint(x, y, snapDist = 18) {
      let nearest = null;
      let minDist = snapDist;
      for (const el of elements) {
        const pts = [ [el.x1, el.y1], [el.x2, el.y2] ];
        for (const [px, py] of pts) {
          const d = Math.hypot(px - x, py - y);
          if (d < minDist) {
            minDist = d;
            nearest = {x: px, y: py};
          }
        }
      }
      return nearest;
    }

    canvas.addEventListener('mousedown', e => {
      const rect = canvas.getBoundingClientRect();
      let mx = e.clientX - rect.left;
      let my = e.clientY - rect.top;
      
      // Check toggle switch click
      const ts = toggleSwitch;
      if (mx >= ts.x && mx <= ts.x + ts.width && my >= ts.y && my <= ts.y + ts.height) {
        toggleMode();
        return;
      }
      
      // Check Battery Pack UI interactions
      if (currentMode === 'Battery Pack') {
        const x = UI.leftToolbar.x;
        const y = UI.leftToolbar.y;
        const w = UI.leftToolbar.width;
        
        // Module selector handling
        let moduleY = y + 22;
        const moduleHeight = 32;
        
        // Check module button clicks
        for (let i = 0; i < batteryModules.length; i++) {
          const moduleX = x + (i % 3) * (w / 3);
          const moduleRowY = moduleY + Math.floor(i / 3) * (moduleHeight + 5);
          const moduleW = Math.min(w / 3 - 5, 55);
          
          if (mx >= moduleX && mx <= moduleX + moduleW && 
              my >= moduleRowY && my <= moduleRowY + moduleHeight) {
            
            // Check if clicking delete button
            if (batteryModules.length > 1) {
              const deleteX = moduleX + moduleW - 14;
              const deleteY = moduleRowY + 4;
              const deleteRadius = 8;
              const distToDelete = Math.hypot(mx - (deleteX + 6), my - (deleteY + 6));
              
              if (distToDelete <= deleteRadius) {
                // Delete module
                batteryModules.splice(i, 1);
                if (selectedModuleIndex >= batteryModules.length) {
                  selectedModuleIndex = batteryModules.length - 1;
                }
                redraw();
                return;
              }
            }
            
            // Select module
            selectedModuleIndex = i;
            redraw();
            return;
          }
        }
        
        // Check add module button click
        const addModuleRow = Math.floor(batteryModules.length / 3);
        const addModuleCol = batteryModules.length % 3;
        const addButtonX = x + addModuleCol * (w / 3);
        const addButtonY = moduleY + addModuleRow * (moduleHeight + 5);
        const addButtonW = Math.min(w / 3 - 5, 55);
        
        if (mx >= addButtonX && mx <= addButtonX + addButtonW && 
            my >= addButtonY && my <= addButtonY + moduleHeight) {
          // Add new module
          batteryModules.push({
            id: nextModuleId++,
            name: `Module ${nextModuleId - 1}`,
            cellType: '18650',
            seriesCount: 1,
            parallelCount: 1,
            configText: '1S1P'
          });
          selectedModuleIndex = batteryModules.length - 1;
          redraw();
          return;
        }
        
        const nextSectionY = addButtonY + moduleHeight + 15;
        const dropdownY = nextSectionY + 20;
        
        // Check dropdown click
        if (mx >= x && mx <= x + w && my >= dropdownY && my <= dropdownY + 30) {
          batteryDropdownOpen = !batteryDropdownOpen;
          redraw();
          return;
        }
        
        // Check dropdown options click
        if (batteryDropdownOpen && mx >= x && mx <= x + w) {
          const optionIndex = Math.floor((my - (dropdownY + 30)) / 30);
          if (optionIndex >= 0 && optionIndex < batteryTypes.length) {
            const selectedBattery = batteryTypes[optionIndex].name;
            
            // If Custom Cell is selected, show the custom cell dialog
            if (selectedBattery === 'Custom Cell') {
              batteryDropdownOpen = false;
              showCustomCellDialog();
              redraw();
              return;
            }
            
            batteryModules[selectedModuleIndex].cellType = selectedBattery;
            batteryDropdownOpen = false;
            redraw();
            return;
          }
        }
        
        // Check series dropdown click
        const configY = dropdownY + 60;
        const seriesY = configY + 20;
        const seriesDropdownY = seriesY + 18;
        if (mx >= x && mx <= x + w && my >= seriesDropdownY && my <= seriesDropdownY + 28) {
          seriesDropdownOpen = !seriesDropdownOpen;
          parallelDropdownOpen = false; // Close other dropdown
          redraw();
          return;
        }
        
        // Check series dropdown options click
        if (seriesDropdownOpen && mx >= x && mx <= x + w) {
          const options = [1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16];
          const optionIndex = Math.floor((my - (seriesDropdownY + 28)) / 28);
          if (optionIndex >= 0 && optionIndex < options.length) {
            batteryModules[selectedModuleIndex].seriesCount = options[optionIndex];
            seriesDropdownOpen = false;
            redraw();
            return;
          }
        }
        
        // Check parallel dropdown click
        const parallelY = seriesDropdownY + 38;
        const parallelDropdownY = parallelY + 18;
        if (mx >= x && mx <= x + w && my >= parallelDropdownY && my <= parallelDropdownY + 28) {
          parallelDropdownOpen = !parallelDropdownOpen;
          seriesDropdownOpen = false; // Close other dropdown
          redraw();
          return;
        }
        
        // Check parallel dropdown options click
        if (parallelDropdownOpen && mx >= x && mx <= x + w) {
          const options = [1, 2, 3, 4, 5, 6, 7, 8, 10, 12];
          const optionIndex = Math.floor((my - (parallelDropdownY + 28)) / 28);
          if (optionIndex >= 0 && optionIndex < options.length) {
            batteryModules[selectedModuleIndex].parallelCount = options[optionIndex];
            parallelDropdownOpen = false;
            redraw();
            return;
          }
        }
        
        // Check Generate Schema button click
        if (uiButtons.generateSchema && uiButtons.generateSchema[0]) {
          const btn = uiButtons.generateSchema[0];
          if (isPointInButton(mx, my, btn)) {
            btn.action();
            return;
          }
        }
        
        // Check editing tool buttons click
        if (uiButtons.batteryEditTools) {
          for (const btn of uiButtons.batteryEditTools) {
            if (isPointInButton(mx, my, btn)) {
              btn.action();
              redraw();
              return;
            }
          }
        }
        
        // Close dropdowns if clicking outside (but inside the left toolbar area)
        if ((batteryDropdownOpen || seriesDropdownOpen || parallelDropdownOpen) &&
            mx >= x && mx <= x + w) {
          batteryDropdownOpen = false;
          seriesDropdownOpen = false;
          parallelDropdownOpen = false;
          redraw();
          return;
        }
      }
      
      // Check if clicking on any UI button (screen coordinates)
      const allButtons = [
        ...uiButtons.leftToolbar,
        ...uiButtons.rightSidebar,
        ...uiButtons.topBar,
        ...uiButtons.bottomCircuits
      ];
      
      for (const btn of allButtons) {
        if (btn.isSeparator) continue; // Skip separators
        if (isPointInButton(mx, my, btn)) {
          if (btn.action) btn.action();
          return;
        }
      }
      
      // Check if click is outside drawing area
      if (mx < UI.drawingArea.x || mx > UI.drawingArea.x + UI.drawingArea.width ||
          my < UI.drawingArea.y || my > UI.drawingArea.y + UI.drawingArea.height) {
        return; // Ignore clicks outside drawing area
      }
      
      if (tool === 'pan') {
        // Start panning
        isPanning = true;
        panStart = { x: mx - panOffset.x, y: my - panOffset.y };
        canvas.style.cursor = 'grabbing';
        return;
      }
      
      // Transform mouse coordinates for zoomed/panned canvas (relative to drawing area)
      const drawingX = mx - UI.drawingArea.x;
      const drawingY = my - UI.drawingArea.y;
      const transformed = {
        x: (drawingX - panOffset.x) / scale,
        y: (drawingY - panOffset.y) / scale
      };
      mx = transformed.x;
      my = transformed.y;
      
      if (tool === 'move') {
        // Find component to move
        for (let i = elements.length - 1; i >= 0; i--) {
          const el = elements[i];
          if (isNearLine(mx, my, el.x1, el.y1, el.x2, el.y2, 16)) {
            movingComponent = el;
            // Calculate offset from mouse to component's first point
            moveOffset = {
              x1: mx - el.x1,
              y1: my - el.y1,
              x2: mx - el.x2,
              y2: my - el.y2
            };
            drawing = true;
            canvas.style.cursor = 'move';
            return;
          }
        }
        return;
      }
      
      if (tool === 'selectArea') {
        // Start area selection
        selectionBox = { x1: mx, y1: my, x2: mx, y2: my };
        selectedElements = [];
        drawing = true;
        return;
      }
      
      // Snap start point if near existing endpoint
      const snap = findNearestEndpoint(mx, my);
      if (snap) { mx = snap.x; my = snap.y; }
      startX = mx;
      startY = my;
      drawing = true;
      if (tool === 'erase') {
        eraseAt(startX, startY);
        drawing = false;
      }
    });
    canvas.addEventListener('mouseup', e => {
      if (tool === 'pan' && isPanning) {
        isPanning = false;
        canvas.style.cursor = 'grab';
        return;
      }
      
      if (tool === 'move' && movingComponent) {
        movingComponent = null;
        drawing = false;
        canvas.style.cursor = 'default';
        circuitEdited = true;
        redraw();
        return;
      }
      
      if (!drawing) return;
      const rect = canvas.getBoundingClientRect();
      let endX = e.clientX - rect.left;
      let endY = e.clientY - rect.top;
      
      // Transform coordinates (relative to drawing area)
      const drawingX = endX - UI.drawingArea.x;
      const drawingY = endY - UI.drawingArea.y;
      const transformed = {
        x: (drawingX - panOffset.x) / scale,
        y: (drawingY - panOffset.y) / scale
      };
      endX = transformed.x;
      endY = transformed.y;
      
      if (tool === 'selectArea' && selectionBox) {
        // Complete area selection
        selectionBox.x2 = endX;
        selectionBox.y2 = endY;
        
        // Find elements within selection box
        const minX = Math.min(selectionBox.x1, selectionBox.x2);
        const maxX = Math.max(selectionBox.x1, selectionBox.x2);
        const minY = Math.min(selectionBox.y1, selectionBox.y2);
        const maxY = Math.max(selectionBox.y1, selectionBox.y2);
        
        selectedElements = elements.filter(el => {
          // Check if element's endpoints are within the selection box
          return (el.x1 >= minX && el.x1 <= maxX && el.y1 >= minY && el.y1 <= maxY) ||
                 (el.x2 >= minX && el.x2 <= maxX && el.y2 >= minY && el.y2 <= maxY);
        });
        
        selectionBox = null;
        drawing = false;
        redraw();
        return;
      }
      
      // Snap end point if near existing endpoint
      const snap = findNearestEndpoint(endX, endY);
      if (snap) { endX = snap.x; endY = snap.y; }
      if (tool === 'wire' || tool === 'resistor' || tool === 'capacitor' || tool === 'inductor' || tool === 'diode' || tool === 'battery') {
        undoStack.push([...elements]);
        redoStack = [];
        let label = '';
        let value = '';
        // Auto-assign labels and default values for resistors and capacitors
        if (tool === 'resistor') {
          label = 'R' + resistorCount;
          value = '5 Œ©';
          resistorCount++;
        } else if (tool === 'capacitor') {
          label = 'C' + capacitorCount;
          capacitorCount++;
        } else if (tool === 'inductor') {
          label = 'L' + inductorCount;
          value = '1 H';
          inductorCount++;
        } else if (tool === 'diode') {
          label = 'D' + diodeCount;
          value = '1N4148';
          diodeCount++;
        } else if (tool === 'battery') {
          label = 'B' + batteryCount;
          value = '5 V';
          batteryCount++;
        }
        const newElement = { type: tool, x1: startX, y1: startY, x2: endX, y2: endY, label: label, value: value };
        // Add internal resistance property for batteries
        if (tool === 'battery') {
          newElement.resistance = '0.1 Œ©'; // Default internal resistance
        }
        elements.push(newElement);
        circuitEdited = true; // Mark circuit as edited
        redraw();
      }
      drawing = false;
    });
    // Undo/Redo logic
    function undo() {
      if (undoStack.length > 0) {
        redoStack.push([...elements]);
        elements = undoStack.pop();
        redraw();
      }
    }
    function redo() {
      if (redoStack.length > 0) {
        undoStack.push([...elements]);
        elements = redoStack.pop();
        redraw();
      }
    }
    
    // JSON file upload handler
    document.getElementById('jsonFileInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(event) {
        try {
          const jsonData = JSON.parse(event.target.result);
          
          // Validate required fields
          if (!jsonData.name || jsonData.voltage === undefined || jsonData.capacity === undefined) {
            alert('Invalid JSON format. Required fields: name, voltage, capacity');
            return;
          }
          
          // Populate form fields with JSON data
          document.getElementById('customCellName').value = jsonData.name || 'Custom Cell';
          document.getElementById('customCellVoltage').value = jsonData.voltage || 3.7;
          document.getElementById('customCellCapacity').value = jsonData.capacity || 3000;
          document.getElementById('customCellChemistry').value = jsonData.chemistry || 'Li-ion';
          document.getElementById('customCellWeight').value = jsonData.weight || 48;
          document.getElementById('customCellDiameter').value = jsonData.diameter !== undefined ? jsonData.diameter : 18.5;
          document.getElementById('customCellLength').value = jsonData.length !== undefined ? jsonData.length : 65.2;
          document.getElementById('customCellTempMin').value = jsonData.tempMin !== undefined ? jsonData.tempMin : -20;
          document.getElementById('customCellTempMax').value = jsonData.tempMax !== undefined ? jsonData.tempMax : 60;
          document.getElementById('customCellTempOptimal').value = jsonData.tempOptimal !== undefined ? jsonData.tempOptimal : 20;
          document.getElementById('customCellTempCoeff').value = jsonData.tempCoefficient !== undefined ? jsonData.tempCoefficient : -0.5;
          document.getElementById('customCellResistance').value = jsonData.internalResistance !== undefined ? jsonData.internalResistance : 45;
          document.getElementById('customCellEfficiency').value = jsonData.thermalEfficiency !== undefined ? jsonData.thermalEfficiency : 95;
          document.getElementById('customCellCycleLife').value = jsonData.cycleLife || 500;
          document.getElementById('customCellSelfDischarge').value = jsonData.selfDischarge || '2-3%/month';
          document.getElementById('customCellReaction').value = jsonData.reaction || 'LiCoO‚ÇÇ + C‚ÇÜ ‚áå Li‚ÇÅ‚Çã‚ÇìCoO‚ÇÇ + Li‚ÇìC‚ÇÜ';
          
          alert(`JSON file loaded successfully! Review the values and click "Save Custom Cell" to apply.`);
        } catch (error) {
          alert('Error parsing JSON file: ' + error.message);
        }
      };
      reader.readAsText(file);
      
      // Reset file input so the same file can be uploaded again
      e.target.value = '';
    });
    
    window.addEventListener('keydown', function(e) {
      if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase() === 'z') {
        e.preventDefault();
        undo();
      } else if ((e.ctrlKey || e.metaKey) && (e.key.toLowerCase() === 'y' || (e.shiftKey && e.key.toLowerCase() === 'z'))) {
        e.preventDefault();
        redo();
      } else if (e.key === 'Delete' || e.key === 'Backspace') {
        // Delete selected elements when Delete or Backspace is pressed
        if (selectedElements.length > 0) {
          e.preventDefault();
          undoStack.push([...elements]);
          redoStack = [];
          // Remove all selected elements
          elements = elements.filter(el => !selectedElements.includes(el));
          selectedElements = [];
          circuitEdited = true;
          redraw();
        }
      }
    });
    // Enable label/value editing only in select mode
    canvas.addEventListener('click', function(e) {
      if ((tool !== 'select' && tool !== 'selectNode') || drawing) return;
      const rect = canvas.getBoundingClientRect();
      let mx = e.clientX - rect.left;
      let my = e.clientY - rect.top;
      
      // Check if click is outside drawing area
      if (mx < UI.drawingArea.x || mx > UI.drawingArea.x + UI.drawingArea.width ||
          my < UI.drawingArea.y || my > UI.drawingArea.y + UI.drawingArea.height) {
        return; // Ignore clicks outside drawing area
      }
      
      // Transform coordinates (relative to drawing area)
      const drawingX = mx - UI.drawingArea.x;
      const drawingY = my - UI.drawingArea.y;
      const transformed = {
        x: (drawingX - panOffset.x) / scale,
        y: (drawingY - panOffset.y) / scale
      };
      mx = transformed.x;
      my = transformed.y;
      
      // Find topmost element near click
      if (tool === 'select') {
        let foundElement = false;
        for (let i = elements.length - 1; i >= 0; i--) {
          const el = elements[i];
          if (isNearLine(mx, my, el.x1, el.y1, el.x2, el.y2, 16)) {
            foundElement = true;
            // Set selected component for visual highlight
            selectedComponent = el;
            
            if (!el.label) el.label = '';
            if (!el.value) el.value = '';
            // Save state for undo
            undoStack.push([...elements]);
            redoStack = [];
            
            // Provide default units for value
            let defaultUnit = '';
            if (el.type === 'resistor') defaultUnit = 'Œ©';
            else if (el.type === 'capacitor') defaultUnit = 'F';
            else if (el.type === 'inductor') defaultUnit = 'H';
            else if (el.type === 'diode') defaultUnit = '';
            else if (el.type === 'battery') defaultUnit = 'V';
            else if (el.type === 'wire') defaultUnit = '';
            
            let valuePrompt = el.value;
            
            // Show custom dialog
            showDialog(
              'Edit ' + el.type.charAt(0).toUpperCase() + el.type.slice(1),
              el.label,
              valuePrompt,
              defaultUnit,
              el // Pass element reference for battery resistance handling
            ).then(result => {
              if (result !== null) {
                el.label = result.label;
                el.value = result.value;
                // Update resistance for batteries
                if (el.type === 'battery' && result.resistance !== undefined) {
                  el.resistance = result.resistance;
                }
                circuitEdited = true; // Mark circuit as edited
                redraw();
              } else {
                // User cancelled, revert undo stack
                undoStack.pop();
                selectedComponent = null; // Clear selection if cancelled
                redraw();
              }
            });
            break;
          }
        }
        // If clicked outside any element, clear selection
        if (!foundElement) {
          selectedComponent = null;
          redraw();
        }
      } else if (tool === 'selectNode') {
        // Find all endpoints
        let endpoints = [];
        for (const el of elements) {
          endpoints.push({x: el.x1, y: el.y1});
          endpoints.push({x: el.x2, y: el.y2});
        }
        // Group endpoints by proximity
        function findOrAdd(arr, pt) {
          for (const obj of arr) {
            if (Math.abs(obj.x - pt.x) < 8 && Math.abs(obj.y - pt.y) < 8) return obj;
          }
          arr.push({...pt, count: 0});
          return arr[arr.length-1];
        }
        let nodeCounts = [];
        for (const pt of endpoints) {
          let node = findOrAdd(nodeCounts, pt);
          node.count++;
        }
        // Find a node near click with count > 1 (joint)
        let found = null;
        for (const node of nodeCounts) {
          if (node.count > 1 && Math.hypot(node.x - mx, node.y - my) < 14) {
            found = node;
            break;
          }
        }
        if (found) {
          selectedNode = {x: found.x, y: found.y};
        } else {
          selectedNode = null;
        }
        redraw();
      }
    });
    // Helper to check if a point is near a line segment
    function isNearLine(x, y, x1, y1, x2, y2, tolerance = 12) {
      // Calculate distance from (x, y) to segment (x1, y1)-(x2, y2)
      const A = x - x1;
      const B = y - y1;
      const C = x2 - x1;
      const D = y2 - y1;
      const dot = A * C + B * D;
      const len_sq = C * C + D * D;
      let param = -1;
      if (len_sq !== 0) param = dot / len_sq;
      let xx, yy;
      if (param < 0) { xx = x1; yy = y1; }
      else if (param > 1) { xx = x2; yy = y2; }
      else { xx = x1 + param * C; yy = y1 + param * D; }
      const dx = x - xx, dy = y - yy;
      return Math.sqrt(dx * dx + dy * dy) < tolerance;
    }

    // Remove label/value editing on click
    // Optional: show preview while drawing
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      let mx = e.clientX - rect.left;
      let my = e.clientY - rect.top;
      
      // Check for Generate Schema button hover in Battery Pack mode
      if (currentMode === 'Battery Pack' && uiButtons.generateSchema && uiButtons.generateSchema[0]) {
        const btn = uiButtons.generateSchema[0];
        if (isPointInButton(mx, my, btn)) {
          if (hoveredButton !== btn) {
            hoveredButton = btn;
            redraw();
          }
        } else if (hoveredButton === btn) {
          hoveredButton = null;
          redraw();
        }
      }
      
      // Check for editing tool button hover in Battery Pack mode
      if (currentMode === 'Battery Pack' && uiButtons.batteryEditTools) {
        let foundHover = false;
        for (const btn of uiButtons.batteryEditTools) {
          if (isPointInButton(mx, my, btn)) {
            if (hoveredButton !== btn) {
              hoveredButton = btn;
              redraw();
            }
            foundHover = true;
            break;
          }
        }
        if (!foundHover && hoveredButton && uiButtons.batteryEditTools.includes(hoveredButton)) {
          hoveredButton = null;
          redraw();
        }
      }
      
      // Check for dropdown hover in Battery Pack mode
      if (currentMode === 'Battery Pack') {
        const x = UI.leftToolbar.x;
        const y = UI.leftToolbar.y;
        const w = UI.leftToolbar.width;
        
        // Recalculate positions accounting for module selector
        const moduleY = y + 22;
        const moduleHeight = 32;
        const addModuleRow = Math.floor(batteryModules.length / 3);
        const addButtonY = moduleY + addModuleRow * (moduleHeight + 5);
        const nextSectionY = addButtonY + moduleHeight + 15;
        const dropdownY = nextSectionY + 20;
        
        // Battery type dropdown hover
        if (batteryDropdownOpen && mx >= x && mx <= x + w) {
          const optionIndex = Math.floor((my - (dropdownY + 30)) / 30);
          if (optionIndex >= 0 && optionIndex < batteryTypes.length) {
            const newHover = batteryTypes[optionIndex].name;
            if (hoveredBatteryType !== newHover) {
              hoveredBatteryType = newHover;
              redraw();
            }
          } else if (hoveredBatteryType !== null) {
            hoveredBatteryType = null;
            redraw();
          }
        }
        
        // Series dropdown hover
        if (seriesDropdownOpen && mx >= x && mx <= x + w) {
          const configY = dropdownY + 60;
          const seriesY = configY + 20;
          const seriesDropdownY = seriesY + 18;
          const options = [1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16];
          const optionIndex = Math.floor((my - (seriesDropdownY + 28)) / 28);
          if (optionIndex >= 0 && optionIndex < options.length) {
            const newHover = options[optionIndex];
            if (hoveredSeriesCount !== newHover) {
              hoveredSeriesCount = newHover;
              redraw();
            }
          } else if (hoveredSeriesCount !== null) {
            hoveredSeriesCount = null;
            redraw();
          }
        }
        
        // Parallel dropdown hover
        if (parallelDropdownOpen && mx >= x && mx <= x + w) {
          const configY = dropdownY + 60;
          const seriesY = configY + 20;
          const seriesDropdownY = seriesY + 18;
          const parallelY = seriesDropdownY + 38;
          const parallelDropdownY = parallelY + 18;
          const options = [1, 2, 3, 4, 5, 6, 7, 8, 10, 12];
          const optionIndex = Math.floor((my - (parallelDropdownY + 28)) / 28);
          if (optionIndex >= 0 && optionIndex < options.length) {
            const newHover = options[optionIndex];
            if (hoveredParallelCount !== newHover) {
              hoveredParallelCount = newHover;
              redraw();
            }
          } else if (hoveredParallelCount !== null) {
            hoveredParallelCount = null;
            redraw();
          }
        }
      }
      
      // Check for button hover
      const allButtons = [
        ...uiButtons.leftToolbar,
        ...uiButtons.rightSidebar,
        ...uiButtons.topBar,
        ...uiButtons.bottomCircuits
      ];
      
      let foundHover = false;
      for (const btn of allButtons) {
        if (btn.isSeparator) continue; // Skip separators
        if (isPointInButton(mx, my, btn)) {
          if (hoveredButton !== btn) {
            hoveredButton = btn;
            redraw();
          }
          foundHover = true;
          break;
        }
      }
      
      if (!foundHover && hoveredButton) {
        hoveredButton = null;
        redraw();
      }
      
      if (tool === 'pan') {
        canvas.style.cursor = isPanning ? 'grabbing' : 'grab';
        if (isPanning) {
          panOffset.x = mx - panStart.x;
          panOffset.y = my - panStart.y;
          redraw();
        }
        return;
      }
      
      if (!drawing) return;
      
      // Transform coordinates (relative to drawing area)
      const drawingX = mx - UI.drawingArea.x;
      const drawingY = my - UI.drawingArea.y;
      const transformed = {
        x: (drawingX - panOffset.x) / scale,
        y: (drawingY - panOffset.y) / scale
      };
      mx = transformed.x;
      my = transformed.y;
      
      if (tool === 'move' && movingComponent) {
        // Move the component
        movingComponent.x1 = mx - moveOffset.x1;
        movingComponent.y1 = my - moveOffset.y1;
        movingComponent.x2 = mx - moveOffset.x2;
        movingComponent.y2 = my - moveOffset.y2;
        redraw();
        return;
      }
      
      if (tool === 'selectArea' && selectionBox) {
        // Update selection box while dragging
        selectionBox.x2 = mx;
        selectionBox.y2 = my;
        redraw();
        return;
      }
      
      if (tool === 'erase') return;
      
      redraw();
      
      // Draw preview in transformed space
      ctx.save();
      ctx.beginPath();
      ctx.rect(UI.drawingArea.x, UI.drawingArea.y, UI.drawingArea.width, UI.drawingArea.height);
      ctx.clip();
      ctx.translate(UI.drawingArea.x + panOffset.x, UI.drawingArea.y + panOffset.y);
      ctx.scale(scale, scale);
      
      let endX = mx;
      let endY = my;
      // Snap preview end point if near existing endpoint
      const snap = findNearestEndpoint(endX, endY);
      if (snap) { endX = snap.x; endY = snap.y; }
      if (tool === 'wire') drawWire(startX, startY, endX, endY);
      if (tool === 'resistor') drawResistor(startX, startY, endX, endY);
      if (tool === 'capacitor') drawCapacitor(startX, startY, endX, endY);
      if (tool === 'inductor') drawInductor(startX, startY, endX, endY);
      if (tool === 'diode') drawDiode(startX, startY, endX, endY);
      if (tool === 'battery') drawBattery(startX, startY, endX, endY);
      
      ctx.restore();
    });
  </script>
  <!-- Hidden file input for JSON upload -->
  <input type="file" id="jsonFileInput" accept=".json" style="display: none;">
</body>
</html>
